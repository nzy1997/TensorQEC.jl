var documenterSearchIndex = {"docs":
[{"location":"man/","page":"Manual","title":"Manual","text":"Documentation for TensorQEC.","category":"page"},{"location":"man/","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"man/","page":"Manual","title":"Manual","text":"Modules = [TensorQEC]","category":"page"},{"location":"man/#TensorQEC.CSSBimatrix","page":"Manual","title":"TensorQEC.CSSBimatrix","text":"CSSBimatrix\n\nSince the encding process may alter the generators of stabilizer group, we introduce the CSSBimatrix structure to store the information of encoding process. The CSSBimatrix structure contains the following fields\n\nmatrix: The bimatrix representation of the stabilizers.\nQ: The matrix records the Gaussian elimination process, whcih is used to recover the original stabilizers.\nordering: The ordering of qubits.\nxcodenum: The number of X stabilizers.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.CliffordSimulateResult","page":"Manual","title":"TensorQEC.CliffordSimulateResult","text":"CliffordSimulateResult{N}\n\nThe result of simulating a Pauli string by a Clifford circuit.\n\nFields\n\noutput::PauliString{N}: A mapped Pauli string as the output.\nphase::ComplexF64: The phase factor.\ncircuit::ChainBlock: The circuit (simplified, with linear structure).\nhistory::Vector{PauliString{N}}: The history of Pauli strings, its length is length(circuit)+1.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.Code1573","page":"Manual","title":"TensorQEC.Code1573","text":"Code1573\n\nConstruct a [[15,7,3]] CSS code instance.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.Code422","page":"Manual","title":"TensorQEC.Code422","text":"Code422\n\nConstruct a [[4,2,2]] CSS code instance.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.Code513","page":"Manual","title":"TensorQEC.Code513","text":"Code513\n\nConstruct a [[5,1,3]] code instance.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.Code832","page":"Manual","title":"TensorQEC.Code832","text":"Code832\n\nConstruct a [[8,3,2]] CSS code instance.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.PauliString","page":"Manual","title":"TensorQEC.PauliString","text":"PauliString{N} <: CompositeBlock{2}\n\nA Pauli string is a tensor product of Pauli gates, e.g. XYZ. The matrix representation of a Pauli string is evaluated as\n\nA = bigotimes_i=1^N sigma_idsN-i+1\n\nwhere ids is the array of integers representing the Pauli gates. Note the order of ids is following the little-endian convention, i.e. the first qubit is the least significant qubit. For example, the Pauli string XYZ has matrix representation Z ⊗ Y ⊗ X.\n\nFields\n\nids::NTuple{N, Int}: the array of integers (1-4) representing the Pauli gates.\n1: I (σ_0)\n2: X (σ_1)\n3: Y (σ_2)\n4: Z (σ_3)\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.QCInfo","page":"Manual","title":"TensorQEC.QCInfo","text":"QCInfo(data_qubits::Vector{Int},ancilla_qubits::Vector{Int},nq::Int)\nQCInfo(data_qubits::Vector{Int},nq::Int)\n\nA struct to store the qubit information of a quantum circuit.\n\nFields\n\ndata_qubits: The data qubit indices.\nancilla_qubits: The ancilla qubit indices. If not specified, it is set to the complement of data_qubits in 1:nq\nnq: The total number of qubits.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.ShorCode","page":"Manual","title":"TensorQEC.ShorCode","text":"ShorCode\n\nConstruct a Shor code instance.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.SimpleTannerGraph","page":"Manual","title":"TensorQEC.SimpleTannerGraph","text":"SimpleTannerGraph(nq::Int, sts::Vector{Vector{Int}})\n\nConstruct a simple tanner graph from a list of stabilizers. Input:     nq: number of qubits     sts: a list of stabilizers, each stabilizer is a list of qubits\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.SteaneCode","page":"Manual","title":"TensorQEC.SteaneCode","text":"SteaneCode\n\nConstruct a Steane code instance.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.SurfaceCode","page":"Manual","title":"TensorQEC.SurfaceCode","text":"SurfaceCode(m::Int, n::Int)\n\nConstruct a surface code with m rows and n columns. \n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.ToricCode","page":"Manual","title":"TensorQEC.ToricCode","text":"ToricCode(m::Int, n::Int)\n\nConstruct a Toric code with m rows and n columns. \n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.TruthTable","page":"Manual","title":"TensorQEC.TruthTable","text":"TruthTable\n\nThe truth table for error correction.\n\nFields\n\ntable::Dict{Int,Int}: The truth table for error correction.\nnum_qubits::Int: The number of qubits.\nnum_st::Int: The number of stabilizers.\nd::Int64: The maximum number of errors.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.annotate_history-Union{Tuple{TensorQEC.CliffordSimulateResult{N}}, Tuple{N}} where N","page":"Manual","title":"TensorQEC.annotate_history","text":"annotate_history(res::CliffordSimulateResult{N})\n\nAnnotate the history of Pauli strings in the result of clifford_simulate.\n\nArguments\n\nres: The result of clifford_simulate.\n\nReturns\n\ndraw: The visualization of the history.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.clifford_group-Tuple{Int64}","page":"Manual","title":"TensorQEC.clifford_group","text":"clifford_group(n::Int)\n\nGenerate the n-qubit Clifford group.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.clifford_network-Tuple{YaoBlocks.ChainBlock}","page":"Manual","title":"TensorQEC.clifford_network","text":"clifford_network(qc::ChainBlock)\n\nGenerate a Clifford network from a quantum circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.clifford_simulate-Union{Tuple{N}, Tuple{PauliString{N}, YaoBlocks.ChainBlock}} where N","page":"Manual","title":"TensorQEC.clifford_simulate","text":"clifford_simulate(ps::PauliString, qc::ChainBlock)\n\nMap the Pauli string ps by a quantum circuit qc. \n\nArguments\n\nps: The Pauli string.\nqc: The quantum circuit.\n\nReturns\n\nresult: A CliffordSimulateResult records the output Pauli string, the phase factor, the simplified circuit, and the history of Pauli strings.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.coherent_error_unitary-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Real}} where T","page":"Manual","title":"TensorQEC.coherent_error_unitary","text":"coherent_error_unitary(u::AbstractMatrix{T}, error_rate::Real; cache::Union{Vector, Nothing} = nothing) where T\n\nGenerate the error unitary near the given error rate.\n\nArguments\n\nu: The original unitary.\nerror_rate: The error rate.\ncache: The vector to store the error rate.\n\nReturns\n\nq: The errored unitary.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.correct_circuit-Tuple{TruthTable, AbstractVector{Int64}, Int64}","page":"Manual","title":"TensorQEC.correct_circuit","text":"correct_circuit(table::Dict{Int,Int}, st_pos::Vector{Int},num_qubits::Int,num_st::Int,num_data_qubits::Int)\n\nGenerate the error correction circuit by embedding the truth table into the quantum circuit.\n\nArguments\n\ntable: The truth table for error correction.\nst_pos: The indices of ancilla qubits that measure stabilizers.\nnum_qubits: The total number of qubits in the circuit.\nnum_st: The number of stabilizers.\nnum_data_qubits: The number of data qubits.\n\nReturns\n\nqc: The error correction circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.correction_pauli_string-Tuple{Int64, Dict{Int64, Bool}, Dict{Int64, Vector{Float64}}}","page":"Manual","title":"TensorQEC.correction_pauli_string","text":"correction_pauli_string(qubit_num::Int, syn::Dict{Int, Bool}, prob::Dict{Int, Vector{Float64}})\n\nGenerate the error Pauli string in the coding space. To correct the error, we still need to transform it to the physical space.\n\nArguments\n\nqubit_num: The number of qubits.\nsyn: The syndrome dictionary.\nprob: The inferred error probability of each physical qubit in coding space.\n\nReturns\n\nps: The error Pauli string in the coding space.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.encode_stabilizers-Union{Tuple{AbstractArray{PauliString{N}, 1}}, Tuple{N}} where N","page":"Manual","title":"TensorQEC.encode_stabilizers","text":"encode_stabilizers(stabilizers::AbstractVector{PauliString{N}}) where N\n\nGenerate the encoding circuit for the given stabilizers.\n\nArguments\n\nstabilizers: The vector of pauli strings, composing the generator of stabilizer group.\n\nReturns\n\nqc: The encoding circuit.\ndata_qubits: The indices of data qubits.\nbimat: The structure storing the encoding information.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.error_pairs-Tuple{T} where T<:Real","page":"Manual","title":"TensorQEC.error_pairs","text":"error_pairs(error_rate::T; gates = nothing) where {T <: Real}\n\nGenerate the error pairs for the given error rate.\n\nArguments\n\nerror_rate: The error rate.\ngates: The gates to be errored. If not specified, it is set to [X,Y,Z,H,CCZ,ConstGate.Toffoli,ConstGate.CNOT,ConstGate.CZ]\n\nReturns\n\npairs: The error pairs.\nvec: The vector to store the error rate to each gate.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.error_quantum_circuit-Union{Tuple{T}, Tuple{YaoBlocks.ChainBlock, T}} where T<:Real","page":"Manual","title":"TensorQEC.error_quantum_circuit","text":"error_quantum_circuit(qc::ChainBlock, error_rate::T ) where {T <: Real}\n\nGenerate the error quantum circuit for the given error rate.\n\nArguments\n\nqc: The quantum circuit.\nerror_rate: The error rate.\n\nReturns\n\neqc: The error quantum circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.error_quantum_circuit_pair_replace-Union{Tuple{T}, Tuple{YaoBlocks.ChainBlock, T}} where T<:Real","page":"Manual","title":"TensorQEC.error_quantum_circuit_pair_replace","text":"error_quantum_circuit_pair_replace(qc::ChainBlock, error_rate::T ) where {T <: Real}\nerror_quantum_circuit_pair_replace(qc::ChainBlock, pairs)\n\nGenerate the error quantum circuit for the given error rate. The errored gate to the same type of gate is the same.\n\nArguments\n\nqc: The quantum circuit.\nerror_rate: The error rate.\npairs: The error gates used to replace the original gates.\n\nReturns\n\nqcf: The error quantum circuit.\nvec: The vector to store the error rate to each gate.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.fidelity_tensornetwork-Tuple{YaoBlocks.ChainBlock, QCInfo}","page":"Manual","title":"TensorQEC.fidelity_tensornetwork","text":"fidelity_tensornetwork(qc::ChainBlock,qc_info::QCInfo)\n\nGenerate the tensor network representation of the quantum circuit fidelity with the given QCInfo, where ancilla qubits are initilized at zero state and partial traced after the circuit. The data qubits are traced out.\n\nArguments\n\nqc: The quantum circuit.\nqc_info: The qubit information of the quantum circuit\n\nReturns\n\ntn: The tensor network representation of the quantum circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.inference-Tuple{Vector{Int64}, CSSBimatrix, YaoBlocks.ChainBlock, Vector{Vector{Float64}}}","page":"Manual","title":"TensorQEC.inference","text":"inference(measure_outcome::Vector{Int}, code::CSSBimatrix, qc::ChainBlock, p::Vector{Vector{Float64}})\n\nInfer the error probability of each qubit from the measurement outcome of the stabilizers.\n\nArguments\n\nmeasure_outcome: The measurement outcome of the stabilizers, which is either 1 or -1.\ncode: The structure storing the encoding information.\nqc: The encoding circuit.\np: The prior error probability of each physical qubit.\n\nReturns\n\nps_ec_phy: The error Pauli string for error correction.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.load_table-Tuple{String, Int64, Int64, Int64}","page":"Manual","title":"TensorQEC.load_table","text":"load_table(filename::String)\n\nLoad the truth table for error correction from a file.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.make_table-Union{Tuple{N}, Tuple{Array{PauliString{N}, 1}, Int64}} where N","page":"Manual","title":"TensorQEC.make_table","text":"make_table(st::Vector{PauliString{N}}, d::Int64) where N\n\nGenerate the truth table for error correction.\n\nArguments\n\nst: The vector of Pauli strings, composing the generator of stabilizer group.\nd: The maximum number of errors.\n\nReturns\n\ntable: The truth table for error correction.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.measure_circuit_fault_tol-Union{Tuple{Array{PauliString{N}, 1}}, Tuple{N}} where N","page":"Manual","title":"TensorQEC.measure_circuit_fault_tol","text":"measure_circuit_fault_tol(sts::Vector{PauliString{N}}) where N\n\nGenerate the Shor type measurement circuit for fault tolerant measurement.\n\nArguments\n\nsts: The vector of Pauli strings, composing the generator of stabilizer group.\n\nReturns\n\nqc: The measurement circuit.\nst_pos: The ancilla qubit indices that measrue corresponding stabilizers.\nnum_qubits: The total number of qubits in the circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.measure_circuit_steane-Union{Tuple{N}, Tuple{Int64, Array{PauliString{N}, 1}}} where N","page":"Manual","title":"TensorQEC.measure_circuit_steane","text":"measure_circuit_steane(data_qubit::Int, sts::Vector{PauliString{N}};qcen = nothing) where N\n\nGenerate the Steane type measurement circuit.\n\nArguments\n\ndata_qubit: The index of the data qubit.\nsts: The vector of Pauli strings, composing the generator of stabilizer group.\nqcen: The encoding circuit. If nothing, the measurement circuit will not contain the encoder for ancilla qubits.\n\nReturns\n\nqc: The measurement circuit.\nst_pos: The ancilla qubit indices that measrue corresponding stabilizers.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.measure_syndrome!-Union{Tuple{N}, Tuple{YaoAPI.AbstractRegister, AbstractArray{PauliString{N}, 1}}} where N","page":"Manual","title":"TensorQEC.measure_syndrome!","text":"measure_syndrome!(reg::AbstractRegister, stabilizers::AbstractVector{PauliString{N}}) where N\n\nMeasure the given stabilizers.\n\nArguments\n\nreg: The quantum register.\nstabilizers: The vector of pauli strings, composing the generator of stabilizer group.\n\nReturns\n\nmeasure_outcome: The measurement outcome of the stabilizers, which is either 1 or -1.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.pauli_basis-Tuple{Int64}","page":"Manual","title":"TensorQEC.pauli_basis","text":"pauli_basis(nqubits::Int)\n\nGenerate the n-qubit Pauli basis.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.pauli_decomposition-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Manual","title":"TensorQEC.pauli_decomposition","text":"pauli_decomposition(m::AbstractMatrix)\n\nDecompose a matrix into the Pauli basis.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.pauli_mapping-Tuple{AbstractMatrix}","page":"Manual","title":"TensorQEC.pauli_mapping","text":"pauli_mapping(m::AbstractMatrix)\n\nConvert a linear operator to a matrix in the Pauli basis.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.pauli_string_map_iter-Union{Tuple{N}, Tuple{PauliString{N}, YaoBlocks.ChainBlock}} where N","page":"Manual","title":"TensorQEC.pauli_string_map_iter","text":"pauli_string_map_iter(ps::PauliString{N}, qc::ChainBlock) where N\n\nMap the Pauli string ps by a quantum circuit qc. Return the mapped Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.paulistring-Tuple{Int64, Any, Any}","page":"Manual","title":"TensorQEC.paulistring","text":"paulistring(n::Int, k::Int, ids::Vector{Int}) -> PauliString\n\nCreate a Pauli string with n qubits, where the i-th qubit is k if i is in ids, otherwise 1. k = 1 for I2, 2 for X, 3 for Y, 4 for Z.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.perm_of_paulistring-Tuple{PauliString, Pair{Vector{Int64}, <:LuxurySparse.PermMatrix}}","page":"Manual","title":"TensorQEC.perm_of_paulistring","text":"perm_of_paulistring(ps::PauliString, operation::Pair{Vector{Int}, <:PermMatrix})\n\nMap the Pauli string ps by a permutation matrix pm. Return the mapped Pauli string and the phase factor.\n\nArguments\n\nps: The Pauli string.\noperation: A pair of the positions to apply the permutation and the permutation matrix.\n\nReturns\n\nps: The mapped Pauli string.\nval: The phase factor.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.place_qubits-Tuple{YaoAPI.AbstractRegister, Vector{Int64}, Int64}","page":"Manual","title":"TensorQEC.place_qubits","text":"place_qubits(reg0::AbstractRegister, data_qubits::Vector{Int}, num_qubits::Int)\n\nPlace the data qubits to the specified position. The other qubits are filled with zero state.\n\nArguments\n\nreg0: The data register.\ndata_qubits: The indices of data qubits.\nnum_qubits: The total number of qubits.\n\nReturns\n\nreg: The register with data qubits placed at the specified position.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.save_table-Tuple{TruthTable, String}","page":"Manual","title":"TensorQEC.save_table","text":"same_table(tb::TruthTable, filename::String)\n\nSave the truth table for error correction to a file.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.show_table-Tuple{IO, Dict{Int64, Int64}, Int64, Int64, Int64}","page":"Manual","title":"TensorQEC.show_table","text":"show_table(table::Dict{Int,Int}, num_qubits::Int, num_st::Int)\n\nPrint the error information for each error pattern in the table.\n\nArguments\n\nio: The output stream.\ntable: The truth table for error correction.\nnum_qubits: The number of qubits.\nnum_st: The number of stabilizers.\nd: The maximum number of errors.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.simulation_tensornetwork-Tuple{YaoBlocks.ChainBlock, QCInfo}","page":"Manual","title":"TensorQEC.simulation_tensornetwork","text":"simulation_tensornetwork(qc::ChainBlock,qc_info::QCInfo)\n\nGenerate the tensor network representation of the quantum circuit with the given QCInfo, where ancilla qubits are initilized at zero state and partial traced after the circuit.\n\nArguments\n\nqc: The quantum circuit.\nqc_info: The qubit information of the quantum circuit\n\nReturns\n\ntn: The tensor network representation of the quantum circuit.\ninput_indices: The input indices of the tensor network.\noutput_indices: The output indices of the tensor network.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.stabilizers-Tuple{ToricCode}","page":"Manual","title":"TensorQEC.stabilizers","text":"stabilizers(tc::ToricCode)\nstabilizers(sc::SurfaceCode)\nstabilizers(shor::ShorCode)\nstabilizers(steane::SteaneCode)\nstabilizers(code832::Code832)\n\nGet the stabilizers of the code instances.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.syndrome_inference-Union{Tuple{T}, Tuple{CliffordNetwork{T}, Dict{Int64, Bool}, Vector{Vector{Float64}}}} where T","page":"Manual","title":"TensorQEC.syndrome_inference","text":"syndrome_inference(cl::CliffordNetwork{T}, syn::Dict{Int,Bool}, p::Vector{Vector{Float64}}) where T\n\nInfer the error probability of each qubit from the measurement outcome of the stabilizers.\n\nArguments\n\ncl: The Clifford network.\nsyn: The syndrome dictionary.\np: The prior error probability of each physical qubit.\n\nReturns\n\npinf: The inferred error probability of each physical qubit in coding space. For errored stabilizers, there are two possibilities: X or Y error. For unerrored stabilizers, there are also two possibilities: no error or Z error. For unmeasured qubits, there are four possibilities: no error, X error, Y error, Z error. Therefore the length of each vector in pinf may be 2 or 4.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.table_inference-Tuple{TruthTable, Vector{Int64}}","page":"Manual","title":"TensorQEC.table_inference","text":"table_inference(table::TruthTable, measure_outcome::Vector{Int})\n\nInfer the error type and position from the measure outcome.\n\nArguments\n\ntable: The truth table for error correction.\nmeasure_outcome: The measure outcome of the stabilizers.\n\nReturns\n\nerror: The error type and position. If the syndrome is not in the truth table, it will print \"No such syndrome in the truth table.\" and return nothing\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.to_perm_matrix-Tuple{YaoAPI.AbstractBlock}","page":"Manual","title":"TensorQEC.to_perm_matrix","text":"to_perm_matrix([::Type{T}, ::Type{Ti}, ]matrix_or_yaoblock; atol=1e-8)\n\nConvert a Clifford gate to its permutation representation.\n\nArguments\n\nT: Element type of phase factor.\nTi: Element type of the permutation matrix.\nm: The matrix representation of the gate.\natol: The tolerance to zeros in the matrix.\n\nReturns\n\npm: The permutation matrix. pm.perm is the permutation vector, pm.vals is the phase factor.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.transformed_syndrome_dict-Tuple{Vector{Int64}, CSSBimatrix}","page":"Manual","title":"TensorQEC.transformed_syndrome_dict","text":"transformed_syndrome_dict(measure_outcome::Vector{Int}, code::CSSBimatrix)\n\nGenerate the syndrome dictionary on the transformed stabilizers from the measurement outcome. \n\nArguments\n\nmeasure_outcome: The measurement outcome of the stabilizers, which is either 1 or -1.\ncode: The structure storing the encoding information.\n\nReturns\n\nsyn_dict: The syndrome dictionary on the transformed stabilizers. 1 is transformed to 0, -1 is transformed to 1. \n\n\n\n\n\n","category":"method"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"EditURL = \"../../../examples/codes.jl\"","category":"page"},{"location":"generated/codes/#QEC-Codes","page":"QEC Codes","title":"QEC Codes","text":"","category":"section"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"We provide a number of quantum error correction codes.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"using TensorQEC","category":"page"},{"location":"generated/codes/#Toric-Code","page":"QEC Codes","title":"Toric Code","text":"","category":"section"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"The Toric code is a 2D topological code[Kitaev]. We can define a Toric code instance by ToricCode.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"tc = ToricCode(2, 3)","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"Here is a schematic diagram of 2*3 Toric code: (Image: )","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"The Toric code has two types of stabilizers: X stabilizers and Z stabilizers. X stabilizers are plaquettes of the lattice, and Z stabilizers are vertices of the lattice. We can get the stabilizers of the toric code by","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"st = stabilizers(tc)","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"Note the order of pauli strings is following the big-endian convention. For example, the Pauli string XYZ means X_1Y_2Z_3.","category":"page"},{"location":"generated/codes/#Surface-Code","page":"QEC Codes","title":"Surface Code","text":"","category":"section"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"The surface code is a 2D topological code[Kitaev]. Similarly to Toric code, we can define a surface code instance by SurfaceCode and get the stabilizers of the surface code by stabilizers.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"sc = SurfaceCode(3, 3)\nst = stabilizers(sc)","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"Here is a schematic diagram of 3*3 surface code: (Image: )","category":"page"},{"location":"generated/codes/#Shor-Code","page":"QEC Codes","title":"Shor Code","text":"","category":"section"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"The [[9,1,3]] Shor code[Shor] functions by concatenating each qubit of a phase-flip with a bit-flip repetition code, allowing it to correct both types of errors at the same time. We can define a Shor code instance by ShorCode.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"shor = ShorCode()\nst = stabilizers(shor)","category":"page"},{"location":"generated/codes/#Steane-Code","page":"QEC Codes","title":"Steane Code","text":"","category":"section"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"The [[7,1,3]] Steane is constructed using the classical binary [7,4,3] Hamming code[Steane]. We can define a Steane code instance by SteaneCode.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"(Image: )","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"steane = SteaneCode()\nst = stabilizers(steane)","category":"page"},{"location":"generated/codes/#[[8,3,2]]-Code","page":"QEC Codes","title":"[[8,3,2]] Code","text":"","category":"section"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"The [[8,3,2]] CSS code is the smallest non-trivial 3D color code[Menendez][Code832]. We can define a CSS [[8,3,2]] code instance by Code832.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"(Image: )","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"code832 = Code832()\nst = stabilizers(code832)","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"[Kitaev]: Kitaev, A. Y. Fault-Tolerant Quantum Computation by Anyons. Annals of Physics 2003, 303 (1), 2–30. https://doi.org/10.1016/S0003-4916(02)00018-0.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"[Menendez]: Menendez, D. H.; Ray, A.; Vasmer, M. Implementing Fault-Tolerant Non-Clifford Gates Using the [[8,3,2]] Color Code. arXiv September 15, 2023. http://arxiv.org/abs/2309.08663.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"[Code832]: THE SMALLEST INTERESTING COLOUR CODE","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"[Shor]: Shor, P. W. (1995). Scheme for reducing decoherence in quantum computer memory. Physical Review A, 52(4), R2493–R2496. https://doi.org/10.1103/PhysRevA.52.R2493","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"[Steane]: Steane, A. (1997). Multiple-particle interference and quantum error correction. Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences, 452(1954), 2551–2577. https://doi.org/10.1098/rspa.1996.0136","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"EditURL = \"../../../examples/table.jl\"","category":"page"},{"location":"generated/table/#Inference-with-Truth-Table","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"","category":"section"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"This example demonstrates how to define stabilizers, encode data qubits measure syndromes, use truth table to infer error type and position, and correct the error.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"We take the [[7,1,3]] Steane code as an example. We use Yao.jl to simulate a physical quantum devise and perform error correction.","category":"page"},{"location":"generated/table/#Definition-of-Stabilizers","page":"Inference with Truth Table","title":"Definition of Stabilizers","text":"","category":"section"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"using TensorQEC, TensorQEC.Yao\nst = stabilizers(SteaneCode())","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"Then we can generate the encoding circuits of the stabilizers by encode_stabilizers. qc is the encoding circuit, data_qubits are the qubits that we should put initial qubtis in, and code is the structure records information of the encoding circuit.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"qc, data_qubits, code = encode_stabilizers(st)\nvizcircuit(qc)","category":"page"},{"location":"generated/table/#Construction-of-the-Truth-Table","page":"Inference with Truth Table","title":"Construction of the Truth Table","text":"","category":"section"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"We can generate the truth table for the error correction by make_table. The TruthTable is a struct that records the truth table, the number of qubits, the number of stabilizers, and maximum error legth of the errors.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"table = make_table(st, 1)","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"We can save the truth table to a file by save_table, and load the truth table from a file by load_table.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"save_table(table, \"test_table.txt\")\ntable2 = load_table(\"test_table.txt\", 9, 8, 1)\ntable.table == table2.table","category":"page"},{"location":"generated/table/#Circuit-Simulation-with-Yao.jl","page":"Inference with Truth Table","title":"Circuit Simulation with Yao.jl","text":"","category":"section"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"Create a random qubit state to be encoded.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"reg1 = rand_state(1)","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"We use place_qubits to create a quantum register. data_qubits records the position of data qubits, and the rest ancilla qubits are in the 0rangle state.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"reg = place_qubits(reg1, data_qubits, nqubits(qc))","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"Apply the encoding circuits.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"apply!(reg, qc)","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"Apply an X error on the third qubit.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"apply!(reg, put(7, 5 => Y))","category":"page"},{"location":"generated/table/#Measure-the-Syndrome-and-Inference-the-Error-Type-and-Position","page":"Inference with Truth Table","title":"Measure the Syndrome and Inference the Error Type and Position","text":"","category":"section"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"We first measure the stabilizers to get the error syndrome by measure_syndrome!. 1 means the stabilizer is not violated, and -1 means the stabilizer is violated.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"measure_outcome = measure_syndrome!(reg, st)","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"The measrue outcome shows that the stabilizer 1,3,4 and 6 are violated. According to the truth table, the error is X_5 and Z_5, which is exactly the error we applied. We can use table_inference to look up the syndromes in the truth table and infer the error type and position.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"table_inference(table, measure_outcome)","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"If we look up the syndrome that is not in the truth table, it will return nothing.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"table_inference(table, [-1,-1,-1,-1,1,1])","category":"page"},{"location":"generated/table/#Error-Correction","page":"Inference with Truth Table","title":"Error Correction","text":"","category":"section"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"Then the following error correction is trivial. We apply the error correction.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"apply!(reg, put(7, 5 => X))\napply!(reg, put(7, 5 => Z))","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"Measure the stabilizers after error correction to check whether the error is corrected.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"measure_syndrome!(reg, st)","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"And we can calculate the fidelity after error correction to check whether the initial state is recovered.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"apply!(reg, qc')\nfidelity_after = fidelity(density_matrix(reg, data_qubits), density_matrix(reg1))","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"EditURL = \"../../../examples/simulation.jl\"","category":"page"},{"location":"generated/simulation/#Measurement-Free-QEC","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"","category":"section"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"This example demonstrates how to use tensor network to simulate a error correction process. We use the 713 steane code and the measurement-free QEC[Heußen] as an example. There are non-clifford gates in the quantum circuit, so we use tensor network to simulate the process.","category":"page"},{"location":"generated/simulation/#Background-Knowledge","page":"Measurement-Free QEC","title":"Background Knowledge","text":"","category":"section"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Traditional quantum error correction requires measurment and feed back into quantum circuit. Limited by laws of physics, measurements are doomed to be costly timewise, e.g. in the NMR computing schme[Boykin]. Decoherence may very well happen during measurement. Measurement-free quantum error correction was a scheme to circumvent this problem.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Measurement-free quantum error correction was first proposed by Aharonov et. al [Aharonov] in the 90s. Without using measurements, a universal set of fault-tolerant gates on encoded qubits was constructed in section 4 of the paper [Aharonov]. They used CSS code and assumed noise is local and un-correlated in time, i.e Markovian. They obtained a threshold of eta_c approx 10^-6, which is the considerably lower than that of the conventional method[DiVincenzo]. This threshold was later improved to be \"only about an order of magnitude worse than conventional schemes\" [Ercan] with the Bacon-Shor code[Paz].","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Experimental realizations include","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Realization on trapped ion platform [Schindler]\nRealization on bosonic code qubits. [Gertler]","category":"page"},{"location":"generated/simulation/#Implementation","page":"Measurement-Free QEC","title":"Implementation","text":"","category":"section"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Traditional quantum error correction involves several key procedures. First, the encoding procedure involves mapping the logical quantum information into a larger, redundant quantum state using QEC codes such as the Shor code or the surface code. Usually, those quantum code are defined by stabilizers. Then, the syndrome extraction is the process that we extract the value of the stabilizers into ancilla qubits. And we measure the ancilla qubits to detect the value of stabilizers. After detection, the error syndromes are identified, which indicates the presence and location of errors in the quantum state. Next, the error correction procedure uses quantum gates to apply operations that reverse the effects of errors, effectively restoring the quantum state to its original form.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"In the measurement-free QEC protocol, we embed the classical truth table of the error correction into the quantum circuit directly. For example, if we measure the stabilizer 1 and 2 to ancilla qubit 1 and 2, and if they are both in state 1rangle, we know that there is an X error on the first qubit. We can encode this information into the quantum circuit directly by a multi-controlled-X gate.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"(Image: )","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Since such multi-controlled gate is non-clifford, we can't simulate it with clifford circuit simulator.","category":"page"},{"location":"generated/simulation/#Definition-of-Stabilizers-and-Encoding-Circuits","page":"Measurement-Free QEC","title":"Definition of Stabilizers and Encoding Circuits","text":"","category":"section"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"using TensorQEC, TensorQEC.Yao\nusing TensorQEC.OMEinsum\nst = stabilizers(SteaneCode())","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Generate the encoding circuits of the stabilizers by encode_stabilizers. qcen is the encoding circuit, data_qubits are the qubits that we should put initial qubtis in, and code is the structure records information of the encoding circuit.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"qcen, data_qubits, code = encode_stabilizers(st)\nvizcircuit(qcen)","category":"page"},{"location":"generated/simulation/#Syndrome-Extraction-and-Measurement-Free-Error-Correction","page":"Measurement-Free QEC","title":"Syndrome Extraction and Measurement-Free Error Correction","text":"","category":"section"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"First, we generate the steane measurement circuit by measure_circuit_steane and st_pos records the ancilla qubits that store the measurement results of the stabilizers.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"qcm,st_pos  = measure_circuit_steane(data_qubits[1],st;qcen)\nvizcircuit(qcm)","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Then we generate truth table for the error correction by make_table. For more detials on truth table, please check Inference with Truth Table.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"table = make_table(st, 1;error_type = \"Z\")","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Now we use correct_circuit to generate the measurement-free correction circuit by encoding the truth table on the quantum circuit directly.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"num_qubits = nqubits(qcm)\nqccr = correct_circuit(table, 22:24, num_qubits)\nvizcircuit(qccr)","category":"page"},{"location":"generated/simulation/#Circuit-Simulation-with-Tensor-Networks","page":"Measurement-Free QEC","title":"Circuit Simulation with Tensor Networks","text":"","category":"section"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"We connect the encoding circuit, the measurement circuit, and the correction circuit to form a full circuit. And we apply a Y error on the third qubit after encoding.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"qcf=chain(subroutine(num_qubits, qcen, 1:7),put(27,3=>Z),qcm,qccr,subroutine(num_qubits, qcen', 1:7))\nvizcircuit(qcf)","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Then we transform the circuit to a tensor network and optimize its contraction order. QCInfo records the information of the quantum circuit, including the data qubits and the number of qubits. fidelity_tensornetwork constructs the tensor network to calculate the fidelity after error correction.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"tn = fidelity_tensornetwork(qcf, QCInfo(data_qubits, 27))","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Finally, we optimize the contraction order and contract the tensor network to get the infidelity after error correction.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"optnet = optimize_code(tn, TreeSA(; ntrials=1, niters=5), OMEinsum.MergeVectors())\ninfidelity = 1 - abs(contract(optnet)[1])","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"[Heußen]: Heußen, S., Locher, D. F., & Müller, M. (2024). Measurement-Free Fault-Tolerant Quantum Error Correction in Near-Term Devices. PRX Quantum, 5(1), 010333. https://doi.org/10.1103/PRXQuantum.5.010333","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"[Aharonov]: Aharonov, D. and Ben-Or, M. (1997). Fault-tolerant quantum computation with constant error. In: Proceedings of the twenty-ninth annual ACM symposium on Theory of computing; pp. 176–188.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"[Boykin]: Roychowdhury, V. P.; Boykin, P.; Vatan, F. and Mor, T. (jul 2004). Fault Tolerant Computation on Ensemble Quantum Computers. In: 2004 International Conference on Dependable Systems and Networks (IEEE Computer Society, Los Alamitos, CA, USA); p. 157.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"[DiVincenzo]: DiVincenzo, D. P. and Aliferis, P. (2007). Effective fault-tolerant quantum computation with slow measurements. Physical review letters 98, 020501.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"[Ercan]: Ercan, H. E.; Ghosh, J.; Crow, D.; Premakumar, V. N.; Joynt, R.; Friesen, M. and Coppersmith, S. (2018). Measurement-free implementations of small-scale surface codes for quantum-dot qubits. Physical Review A 97, 012318.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"[Paz]: Paz-Silva, G. A.; Brennen, G. K. and Twamley, J. (2010). On fault-tolerance with noisy and slow measurements, arXiv preprint arXiv:1002.1536.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"[Schindler]: Schindler, P.; Barreiro, J. T.; Monz, T.; Nebendahl, V.; Nigg, D.; Chwalla, M.; Hennrich, M. and Blatt, R. (2011). Experimental Repetitive Quantum Error Correction. Science 332, 1059–1061, arXiv:https://www.science.org/doi/pdf/10.1126/science.1203329.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"[Gertler]: Gertler, J. M.; Baker, B.; Li, J.; Shirol, S.; Koch, J. and Wang, C. (2021). Protecting a bosonic qubit with autonomous quantum error correction. Nature 590, 243–248.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"EditURL = \"../../../examples/coherent.jl\"","category":"page"},{"location":"generated/coherent/#Coherent-Error-Simulation","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"","category":"section"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"Coherent error or unitary error is a type of error that can be described by a unitary matrix acting on the quantum state. For example, if we want to apply an unitary U on the state, however, we apply a unitary U instead, which differ from U slighty. The error can be described by an unitary E = UU^dagger acting on the quantum state. Usually, this unitary is non-Clifford, thus it is hard to simulate with the stabilizer formalism. Here, we use tensor network to simulate a quantum circuit with coherent error.","category":"page"},{"location":"generated/coherent/#Quantum-Circuit-Construction","page":"Coherent Error Simulation","title":"Quantum Circuit Construction","text":"","category":"section"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"First, we define the stabilizers for Steane code.","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"using TensorQEC, TensorQEC.Yao\nusing TensorQEC.OMEinsum\nst = stabilizers(SteaneCode())","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"Then we generate the encoding circuits of the stabilizers by encode_stabilizers. qc is the encoding circuit, data_qubits are the qubits that we should put initial qubtis in, and code is the structure records information of the encoding circuit.","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"qcen, data_qubits, code = encode_stabilizers(st)\nvizcircuit(qcen)","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"Now we construct a 7-qubit quantum circuit to perform the following operations:","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"Encoding the initial state with the encoding circuit.\nApply an logical X gate which consists of three X gates on the seven qubits.\nDecoding the state with the encoding circuit.\nApply an X gate to recover the initial state.","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"qc = chain(qcen)\npush!(qc, [put(7, i => X) for i in 1:7]...)\npush!(qc, qcen')\npush!(qc, put(7, 6 => X))\nvizcircuit(qc)","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"This circuit should act trivially on the data qubit. We will check this later.","category":"page"},{"location":"generated/coherent/#Circuit-Simulation-with-Tensor-Networks","page":"Coherent Error Simulation","title":"Circuit Simulation with Tensor Networks","text":"","category":"section"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"Simulating quantum circuits using tensor networks is a powerful technique, particularly for circuits that are not easily amenable to simulation with classical computers[Markov]. We can replace gates and density matries by tensors to get the tensor network representation of the quantum circuit. Applying a quantum channel on a density matix is equivalent to connecting two tensors together and contracting them. (Image: )","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"To trace out a matrix in the tensor network, we can simply connect the two indices of the matrix and contract them. To partially trace out the ancilla qubits, we can simply connect the output indices of the ancilla qubits and contract them. (Image: )","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"We can use the function simulation_tensornetwork to generate the tensor network of the quantum channel.","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"tn,input_indices,output_indices = simulation_tensornetwork(qc, QCInfo(data_qubits, 7))","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"And we contract the tensor network to get the matrix representation of the quantum channel, which is an identity channel.","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"optnet = optimize_code(tn, TreeSA(; ntrials=1, niters=3), OMEinsum.MergeVectors())\nmatr = contract(optnet)","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"Also we can compute the circuit fidelity with identity channel directly by connecting the input and output indices of the quantum channel and contracting them. (Image: )","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"fidelity_tensornetwork transforms the circuit to a tensor network to calculate fidelity.","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"tn = fidelity_tensornetwork(qc, QCInfo(data_qubits, 7))\noptnet = optimize_code(tn, TreeSA(; ntrials=1, niters=3), OMEinsum.MergeVectors())\ninfidelity = 1 - abs(contract(optnet)[1])","category":"page"},{"location":"generated/coherent/#Coherent-Error-Simulation-with-Tensor-Network","page":"Coherent Error Simulation","title":"Coherent Error Simulation with Tensor Network","text":"","category":"section"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"We add coherent error to the circuit by adding unitary error to every unitary gate by error_quantum_circuit, which replaces the gates in the original circuit with the errored gates.","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"eqc = error_quantum_circuit(qc, 1e-5)\nvizcircuit(eqc)","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"Finally, we can check the infidelity after the circuit with coherent error.","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"tn = fidelity_tensornetwork(eqc, QCInfo(data_qubits, 7))\noptnet = optimize_code(tn, TreeSA(; ntrials=1, niters=3), OMEinsum.MergeVectors())\ninfidelity = 1 - abs(contract(optnet)[1])","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"[Markov]: Markov, I. L., & Shi, Y. (2008). Simulating Quantum Computation by Contracting Tensor Networks. SIAM Journal on Computing, 38(3), 963–981. https://doi.org/10.1137/050644756","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TensorQEC","category":"page"},{"location":"#TensorQEC","page":"Home","title":"TensorQEC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package utilizes the tensor network to study the properties of quantum error correction(QEC). The main features include","category":"page"},{"location":"","page":"Home","title":"Home","text":"Incoherent Quantum error correction: In the incoherent quantum error correction scheme, finding the most likely true error from the error syndrome is a standard probabilistic inference problem on boolean variables. This problem is closely connected to tensor networks[Ferris], which can be solved with existing tools such as TensorInference.jl. Examples are given in the following sections:\nInference with Tensor Network\nCoherent quantum error correction: Unlike Clifford gate, non-Clifford gates can not be simulated efficiently in general. By converting the quantum circuit into a tensor network, we can simulate small coherent quantum error correction circuits. Examples are given in the following sections:\nCoherent Error Simulation\nMeasurement-Free QEC","category":"page"},{"location":"","page":"Home","title":"Home","text":"[Ferris]: Ferris, A. J.; Poulin, D. Tensor Networks and Quantum Error Correction. Phys. Rev. Lett. 2014, 113 (3), 030501. https://doi.org/10.1103/PhysRevLett.113.030501.","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"EditURL = \"../../../examples/clifford.jl\"","category":"page"},{"location":"generated/clifford/#Pauli-Basis-and-Clifford-group","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"","category":"section"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"In this section, we introduce the definition of Pauli strings and basic operations on them. We also introduce the Clifford group and how to simulate a Clifford circuit applied on Pauli strings.","category":"page"},{"location":"generated/clifford/#Pauli-Strings","page":"Pauli Basis and Clifford group","title":"Pauli Strings","text":"","category":"section"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"A pauli string is a tensor product of Pauli operators acting on different qubits. PauliString is a subtype of [CompositeBlock] with a field ids storing the Pauli operators. We can define pauli string with PauliString or paulistring.","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"using TensorQEC, TensorQEC.Yao\nPauliString(X, I2, Z, Y) # X_1Z_3Y_4\n\npaulistring(4, X, (1, 2, 4)) # X_1X_2X_4","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"We can use Yao.mat to get the matrix representation of a Pauli string.","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"mat(ComplexF64, PauliString(X, Z)) # X_1Z_2","category":"page"},{"location":"generated/clifford/#Pauli-Basis","page":"Pauli Basis and Clifford group","title":"Pauli Basis","text":"","category":"section"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"pauli_basis generates all the Pauli strings of a given length. Those Pauli strings are stored in a high-dimensional array.","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"pauli_basis(2)","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"pauli_decomposition returns the coefficients of a matrix in the Pauli basis.","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"pauli_decomposition(ConstGate.CNOT)","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"That implies that CNOT = frac12 (I otimes I + I otimes X + Z otimes I - Z otimes X). We can check this by","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"0.5*(mat(kron(I2,I2) + kron(I2,X) + kron(Z,I2) - kron(Z,X))) == mat(ConstGate.CNOT)","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"pauli_mapping returns the matrix representation of a quantum gate in the Pauli basis. For Hadamard gate H, we know that HIH = I HXH = Z HYH = -Y HZH = X. We can convert H into the Pauli basis.","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"pauli_mapping(H)","category":"page"},{"location":"generated/clifford/#Clifford-Group","page":"Pauli Basis and Clifford group","title":"Clifford Group","text":"","category":"section"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"Clifford group can be generated by Hadamard gate, S gate and CNOT gate[Bravyi2022]. We can generate the Clifford group with clifford_group.","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"clifford_group(1)","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"Each element in the Clifford group acts on pauli basis as a permutation matrix. For n= 1 2, and 3, this group contains 24, 11520, and 92897280 elements, respectively. We can use to_perm_matrix to convert a matrix into a permutation matrix.","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"pm = to_perm_matrix(H)\npm.perm, pm.vals","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"With the permutation matrix, we can apply a Clifford gate to a Pauli string by perm_of_paulistring. Here we apply the Hadamard gate to the second qubit of Pauli string I_1X_2 and get I_1Z_2 with a phase 1.","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"ps1 = PauliString(I2, X)\nps2, phase = perm_of_paulistring(ps1, [2]=>pm)\nps1, ps2, phase","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"Put those all together, we can apply a Clifford circuit to a Pauli string by clifford_simulate.","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"qc = chain(put(5, 1 => H), control(5, 1, 2 => Z), control(5, 3, 4 => X), control(5, 5, 3 => X), put(5, 1 => X))\nvizcircuit(qc)","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"Apply the circuit to Pauli string Z_1Y_2I_3Y_4X_5, we get Y_1X_2Y_3Y_4Y_5 with a phase 1.","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"ps = PauliString(Z, Y, I2, Y, X)\nres = clifford_simulate(ps, qc)\nps2 = res.output","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"where res.output is the Pauli string after the Clifford circuit and res.phase is the phase factor. It corresponds to the following quantum circuit.","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"clifford_simulation_circuit = chain(qc', ps, qc)\nCircuitStyles.barrier_for_chain[] = true  # setup barrier for better visualization\nvizcircuit(clifford_simulation_circuit)","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"We can check the result by","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"CircuitStyles.barrier_for_chain[] = false  # disable barrier\nres.phase * mat(clifford_simulation_circuit) ≈ mat(ps2)","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"We can also visualize the history of Pauli strings by annotate_history.","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"annotate_history(res)","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"[Bravyi2022]: Bravyi, S., Latone, J.A., Maslov, D., 2022. 6-qubit optimal Clifford circuits. npj Quantum Inf 8, 1–12. https://doi.org/10.1038/s41534-022-00583-7","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"","category":"page"},{"location":"generated/clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"EditURL = \"../../../examples/inference.jl\"","category":"page"},{"location":"generated/inference/#Inference-with-Tensor-Network","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"","category":"section"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"This example demonstrates how to define stabilizers, encode data qubits measure syndromes, and use tensor network to infer the most likely error[Ferris].","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"We take the 3times 3 surface code as an example, and use Yao.jl to verify the error correction circuit.","category":"page"},{"location":"generated/inference/#Definition-of-Stabilizers","page":"Inference with Tensor Network","title":"Definition of Stabilizers","text":"","category":"section"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"using TensorQEC, TensorQEC.Yao\nsurface_stabilizers = stabilizers(SurfaceCode(3,3))","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Then we can generate the encoding circuits of the stabilizers by encode_stabilizers.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"encoder, data_qubits, bimatrix = encode_stabilizers(surface_stabilizers)\nvizcircuit(encoder)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"where encoder is the encoding circuit, data_qubits are the qubits that we should put initial qubtis in, and bimatrix is a CSSBimatrix instance that records information of the encoding circuit. For more details on Bimatrix, please check [Gottesman].","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"The process of obtaining the encoding circuit requires adjusting the generators of the stabilizer group. The new generators are","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"TensorQEC.bimatrix2stabilizers(bimatrix)","category":"page"},{"location":"generated/inference/#Circuit-Simulation-with-Yao.jl","page":"Inference with Tensor Network","title":"Circuit Simulation with Yao.jl","text":"","category":"section"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Create a random qubit state to be encoded.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"data = rand_state(1)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"We use place_qubits to create a quantum register. data_qubits records the position of data qubits, and the rest ancilla qubits are in the 0rangle state.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"logic_state = place_qubits(data, data_qubits, nqubits(encoder))","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Apply the encoding circuits.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"apply!(logic_state, encoder)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Apply an X error on the third qubit.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"apply!(logic_state, put(9, 3 => X))","category":"page"},{"location":"generated/inference/#Measure-the-Syndrome-and-Inference-the-Error-Probability","page":"Inference with Tensor Network","title":"Measure the Syndrome and Inference the Error Probability","text":"","category":"section"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"We first measure the stabilizers to get the error syndrome by measure_syndrome!. 1 means the stabilizer is not violated, and -1 means the stabilizer is violated. Though the stabilizers are not the same as the initial stabilizers, we can't directly measure the current stabilizers to get the syndrome. The reason is that there may be some long range term in the current stabilizers, which can' be measrued physically. So we still measure the initial stabilizers to get the syndrome.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"measure_outcome = measure_syndrome!(logic_state, surface_stabilizers)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Then we transform the syndrome in the current stabilizers by transformed_syndrome_dict. The syndrome is transformed to 0 if the measurement outcome is 1, and 1 if the measurement outcome is -1.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"syn_dict = transformed_syndrome_dict(measure_outcome, bimatrix)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Now we generate the tensor network for syndrome inference by clifford_network.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"tensor_network = clifford_network(encoder)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Define the prior error probability of each physical qubit. Here we assume the error probability of each qubit is the same. There are probability of 85% that the qubits are correct, and 5% that there is an X error, Y error, or Z error respectively.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"prior = fill([0.85, 0.05, 0.05, 0.05], 9)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"We can use the syndrome_inference function to infer the error probability.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"pinf = syndrome_inference(tensor_network, syn_dict, prior)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Generate the Pauli string for error correction. correction_pauli_string generates the error Pauli string in the coding space. To correct the error, we still need to transform it to the physical space by clifford_simulate. The corretion pauli string here is X_6. Since there is a stabilizer X_3X_6, applying X_3 or X_6 on the coding space are equivalent.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"ps_ec_phy = clifford_simulate(correction_pauli_string(9, syn_dict, pinf), encoder).output","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Or we can simply use the inference function to infer error pauli string in one function.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"ps_ec_phy = inference(measure_outcome, bimatrix, encoder, prior)","category":"page"},{"location":"generated/inference/#Error-Correction","page":"Inference with Tensor Network","title":"Error Correction","text":"","category":"section"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Apply the error correction.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"apply!(logic_state, Yao.YaoBlocks.Optimise.to_basictypes(ps_ec_phy))","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Finally, we can measure the stabilizers after error correction to check whether the error is corrected.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"measure_syndrome!(logic_state, surface_stabilizers)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"And we can calculate the fidelity after error correction to check whether the initial state is recovered.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"apply!(logic_state, encoder')\nfidelity_after = fidelity(density_matrix(logic_state, data_qubits), density_matrix(data))","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"[Ferris]: Ferris, A. J.; Poulin, D. Tensor Networks and Quantum Error Correction. Phys. Rev. Lett. 2014, 113 (3), 030501. https://doi.org/10.1103/PhysRevLett.113.030501.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"[Gottesman]: Gottesman, D. (1997). Stabilizer Codes and Quantum Error Correction (arXiv:quant-ph/9705052). arXiv. http://arxiv.org/abs/quant-ph/9705052","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"This page was generated using Literate.jl.","category":"page"}]
}
