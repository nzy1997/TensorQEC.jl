var documenterSearchIndex = {"docs":
[{"location":"man/","page":"Manual","title":"Manual","text":"Documentation for TensorQEC.","category":"page"},{"location":"man/","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"man/","page":"Manual","title":"Manual","text":"Modules = [TensorQEC]","category":"page"},{"location":"man/#TensorQEC.Bimatrix","page":"Manual","title":"TensorQEC.Bimatrix","text":"Bimatrix\n\nSince the encding process may alter the generators of stabilizer group, we introduce the Bimatrix structure to store the information of encoding process. The Bimatrix structure contains the following fields\n\n'matrix': The bimatrix representation of the stabilizers.\n'Q': The matrix records the Gaussian elimination process, whcih is used to recover the original stabilizers.\n'ordering': The ordering of qubits.\n'xcodenum': The number of X stabilizers.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.Code832","page":"Manual","title":"TensorQEC.Code832","text":"Code832\n\nConstruct a [[8,3,2]] CSS code instance.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.PauliString","page":"Manual","title":"TensorQEC.PauliString","text":"PauliString{N} <: CompositeBlock{2}\n\nA Pauli string is a tensor product of Pauli gates, e.g. XYZ. The matrix representation of a Pauli string is evaluated as\n\nA = bigotimes_i=1^N sigma_idsN-i+1\n\nwhere ids is the array of integers representing the Pauli gates. Note the order of ids is following the little-endian convention, i.e. the first qubit is the least significant qubit. For example, the Pauli string XYZ has matrix representation Z ⊗ Y ⊗ X.\n\nFields\n\nids::NTuple{N, Int}: the array of integers (1-4) representing the Pauli gates.\n1: I (σ_0)\n2: X (σ_1)\n3: Y (σ_2)\n4: Z (σ_3)\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.QCInfo","page":"Manual","title":"TensorQEC.QCInfo","text":"QCInfo(data_qubits::Vector{Int},ancilla_qubits::Vector{Int},nq::Int)\nQCInfo(data_qubits::Vector{Int},nq::Int)\n\nA struct to store the qubit information of a quantum circuit.\n\nFields\n\ndata_qubits: The data qubit indices.\nancilla_qubits: The ancilla qubit indices. If not specified, it is set to the complement of data_qubits in 1:nq\nnq: The total number of qubits.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.ShorCode","page":"Manual","title":"TensorQEC.ShorCode","text":"ShorCode\n\nConstruct a Shor code instance.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.SteaneCode","page":"Manual","title":"TensorQEC.SteaneCode","text":"SteaneCode\n\nConstruct a Steane code instance.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.SurfaceCode","page":"Manual","title":"TensorQEC.SurfaceCode","text":"SurfaceCode(m::Int, n::Int)\n\nConstruct a surface code with m rows and n columns. \n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.ToricCode","page":"Manual","title":"TensorQEC.ToricCode","text":"ToricCode(m::Int, n::Int)\n\nConstruct a Toric code with m rows and n columns. \n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.clifford_network-Tuple{YaoBlocks.ChainBlock}","page":"Manual","title":"TensorQEC.clifford_network","text":"clifford_network(qc::ChainBlock)\n\nGenerate a Clifford network from a quantum circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.correct_circuit-Tuple{Dict{Int64, Int64}, Vector{Int64}, Int64, Int64, Int64}","page":"Manual","title":"TensorQEC.correct_circuit","text":"correct_circuit(table::Dict{Int,Int}, st_pos::Vector{Int},num_qubits::Int,num_st::Int,num_data_qubits::Int)\n\nGenerate the error correction circuit by embedding the truth table into the quantum circuit.\n\nArguments\n\ntable: The truth table for error correction.\nst_pos: The indices of ancilla qubits that measure stabilizers.\nnum_qubits: The total number of qubits in the circuit.\nnum_st: The number of stabilizers.\nnum_data_qubits: The number of data qubits.\n\nReturns\n\nqc: The error correction circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.correction_pauli_string-Tuple{Int64, Dict{Int64, Bool}, Dict{Int64, Vector{Float64}}}","page":"Manual","title":"TensorQEC.correction_pauli_string","text":"correction_pauli_string(qubit_num::Int, syn::Dict{Int, Bool}, prob::Dict{Int, Vector{Float64}})\n\nGenerate the error Pauli string in the coding space. To correct the error, we still need to transform it to the physical space.\n\nArguments\n\nqubit_num: The number of qubits.\nsyn: The syndrome dictionary.\nprob: The inferred error probability of each physical qubit in coding space.\n\nReturns\n\nps: The error Pauli string in the coding space.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.encode_stabilizers-Union{Tuple{AbstractArray{PauliString{N}, 1}}, Tuple{N}} where N","page":"Manual","title":"TensorQEC.encode_stabilizers","text":"encode_stabilizers(stabilizers::AbstractVector{PauliString{N}}) where N\n\nGenerate the encoding circuit for the given stabilizers.\n\nArguments\n\nstabilizers: The vector of pauli strings, composing the generator of stabilizer group.\n\nReturns\n\nqc: The encoding circuit.\ndata_qubits: The indices of data qubits.\nbimat: The structure storing the encoding information.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.fidelity_tensornetwork-Tuple{YaoBlocks.ChainBlock, QCInfo}","page":"Manual","title":"TensorQEC.fidelity_tensornetwork","text":"fidelity_tensornetwork(qc::ChainBlock,qc_info::QCInfo)\n\nGenerate the tensor network representation of the quantum circuit fidelity with the given QCInfo, where ancilla qubits are initilized at zero state and partial traced after the circuit.\n\nArguments\n\nqc: The quantum circuit.\nqc_info: The qubit information of the quantum circuit\n\nReturns\n\ntn: The tensor network representation of the quantum circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.inference-Tuple{Vector{Int64}, Bimatrix, YaoBlocks.ChainBlock, Vector{Vector{Float64}}}","page":"Manual","title":"TensorQEC.inference","text":"inference(measure_outcome::Vector{Int}, code::Bimatrix, qc::ChainBlock, p::Vector{Vector{Float64}})\n\nInfer the error probability of each qubit from the measurement outcome of the stabilizers.\n\nArguments\n\nmeasure_outcome: The measurement outcome of the stabilizers, which is either 1 or -1.\ncode: The structure storing the encoding information.\nqc: The encoding circuit.\np: The prior error probability of each physical qubit.\n\nReturns\n\nps_ec_phy: The error Pauli string for error correction.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.load_table-Tuple{String}","page":"Manual","title":"TensorQEC.load_table","text":"load_table(filename::String)\n\nLoad the truth table for error correction from a file.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.make_table-Union{Tuple{N}, Tuple{Array{PauliString{N}, 1}, Int64}} where N","page":"Manual","title":"TensorQEC.make_table","text":"make_table(st::Vector{PauliString{N}}, d::Int64) where N\n\nGenerate the truth table for error correction. Use function show_table to print the table. \n\nArguments\n\nst: The vector of Pauli strings, composing the generator of stabilizer group.\nd: The maximum number of errors.\n\nReturns\n\ntable: The truth table for error correction.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.measure_circuit_fault_tol-Union{Tuple{Array{PauliString{N}, 1}}, Tuple{N}} where N","page":"Manual","title":"TensorQEC.measure_circuit_fault_tol","text":"measure_circuit_fault_tol(sts::Vector{PauliString{N}}) where N\n\nGenerate the Shor type measurement circuit for fault tolerant measurement.\n\nArguments\n\nsts: The vector of Pauli strings, composing the generator of stabilizer group.\n\nReturns\n\nqc: The measurement circuit.\nst_pos: The ancilla qubit indices that measrue corresponding stabilizers.\nnum_qubits: The total number of qubits in the circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.measure_circuit_steane-Union{Tuple{N}, Tuple{YaoBlocks.ChainBlock, Int64, Array{PauliString{N}, 1}, Int64}} where N","page":"Manual","title":"TensorQEC.measure_circuit_steane","text":"measure_circuit_steane(qcen::ChainBlock, data_qubit::Int, sts::Vector{PauliString{N}},xst_num::Int) where N\n\nGenerate the Steane type measurement circuit.\n\nArguments\n\nqcen: The encoding circuit.\ndata_qubit: The index of the data qubit.\nsts: The vector of Pauli strings, composing the generator of stabilizer group.\nxst_num: The number of X type stabilizers.\n\nReturns\n\nqc: The measurement circuit.\nst_pos: The ancilla qubit indices that measrue corresponding stabilizers.\nnum_qubits: The total number of qubits in the circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.measure_syndrome!-Union{Tuple{N}, Tuple{YaoAPI.AbstractRegister, AbstractArray{PauliString{N}, 1}}} where N","page":"Manual","title":"TensorQEC.measure_syndrome!","text":"measure_syndrome!(reg::AbstractRegister, stabilizers::AbstractVector{PauliString{N}}) where N\n\nMeasure the given stabilizers.\n\nArguments\n\nreg: The quantum register.\nstabilizers: The vector of pauli strings, composing the generator of stabilizer group.\n\nReturns\n\nmeasure_outcome: The measurement outcome of the stabilizers, which is either 1 or -1.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.pauli_string_map_iter-Union{Tuple{N}, Tuple{PauliString{N}, YaoBlocks.ChainBlock}} where N","page":"Manual","title":"TensorQEC.pauli_string_map_iter","text":"pauli_string_map_iter(ps::PauliString{N}, qc::ChainBlock) where N\n\nMap the Pauli string ps by a quantum circuit qc. Return the mapped Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.place_qubits-Tuple{YaoAPI.AbstractRegister, Vector{Int64}, Int64}","page":"Manual","title":"TensorQEC.place_qubits","text":"place_qubits(reg0::AbstractRegister, data_qubits::Vector{Int}, num_qubits::Int)\n\nPlace the data qubits to the specified position. The other qubits are filled with zero state.\n\nArguments\n\nreg0: The data register.\ndata_qubits: The indices of data qubits.\nnum_qubits: The total number of qubits.\n\nReturns\n\nreg: The register with data qubits placed at the specified position.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.save_table-Tuple{Dict{Int64, Int64}, String}","page":"Manual","title":"TensorQEC.save_table","text":"save_table(table::Dict{Int,Int}, filename::String)\n\nSave the truth table for error correction to a file.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.show_table-Tuple{Dict{Int64, Int64}, Int64, Int64}","page":"Manual","title":"TensorQEC.show_table","text":"show_table(table::Dict{Int,Int}, num_qubits::Int, num_st::Int)\n\nPrint the error information for each error pattern in the table.\n\nArguments\n\ntable: The truth table for error correction.\nnum_qubits: The number of qubits.\nnum_st: The number of stabilizers.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.stabilizers-Tuple{ToricCode}","page":"Manual","title":"TensorQEC.stabilizers","text":"stabilizers(tc::ToricCode)\nstabilizers(sc::SurfaceCode)\nstabilizers(shor::ShorCode)\nstabilizers(steane::SteaneCode)\nstabilizers(code832::Code832)\n\nGet the stabilizers of the code instances.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.syndrome_inference-Union{Tuple{T}, Tuple{CliffordNetwork{T}, Dict{Int64, Bool}, Vector{Vector{Float64}}}} where T","page":"Manual","title":"TensorQEC.syndrome_inference","text":"syndrome_inference(cl::CliffordNetwork{T}, syn::Dict{Int,Bool}, p::Vector{Vector{Float64}}) where T\n\nInfer the error probability of each qubit from the measurement outcome of the stabilizers.\n\nArguments\n\ncl: The Clifford network.\nsyn: The syndrome dictionary.\np: The prior error probability of each physical qubit.\n\nReturns\n\npinf: The inferred error probability of each physical qubit in coding space. For errored stabilizers, there are two possibilities: X or Y error. For unerrored stabilizers, there are also two possibilities: no error or Z error. For unmeasured qubits, there are four possibilities: no error, X error, Y error, Z error. Therefore the length of each vector in pinf may be 2 or 4.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.transformed_sydrome_dict-Tuple{Vector{Int64}, Bimatrix}","page":"Manual","title":"TensorQEC.transformed_sydrome_dict","text":"transformed_sydrome_dict(measure_outcome::Vector{Int}, code::Bimatrix)\n\nGenerate the syndrome dictionary on the transformed stabilizers from the measurement outcome. \n\nArguments\n\nmeasure_outcome: The measurement outcome of the stabilizers, which is either 1 or -1.\ncode: The structure storing the encoding information.\n\nReturns\n\nsyn_dict: The syndrome dictionary on the transformed stabilizers. 1 is transformed to 0, -1 is transformed to 1. \n\n\n\n\n\n","category":"method"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"EditURL = \"../../../examples/codes.jl\"","category":"page"},{"location":"generated/codes/#QEC-Codes","page":"QEC Codes","title":"QEC Codes","text":"","category":"section"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"We provide a number of quantum error correction codes.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"using TensorQEC","category":"page"},{"location":"generated/codes/#Toric-Code","page":"QEC Codes","title":"Toric Code","text":"","category":"section"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"The Toric code is a 2D topological code[Kitaev]. We can define a Toric code instance by ToricCode.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"tc = ToricCode(2, 3)","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"Here is a schematic diagram of 2*3 Toric code: (Image: )","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"The Toric code has two types of stabilizers: X stabilizers and Z stabilizers. X stabilizers are plaquettes of the lattice, and Z stabilizers are vertices of the lattice. We can get the stabilizers of the toric code by","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"st = stabilizers(tc)","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"Note the order of pauli strings is following the big-endian convention. For example, the Pauli string XYZ means X_1Y_2Z_3.","category":"page"},{"location":"generated/codes/#Surface-Code","page":"QEC Codes","title":"Surface Code","text":"","category":"section"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"The surface code is a 2D topological code[Kitaev]. Similarly to Toric code, we can define a surface code instance by SurfaceCode and get the stabilizers of the surface code by stabilizers.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"sc = SurfaceCode(3, 3)\nst = stabilizers(sc)","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"Here is a schematic diagram of 3*3 surface code: (Image: )","category":"page"},{"location":"generated/codes/#Shor-Code","page":"QEC Codes","title":"Shor Code","text":"","category":"section"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"The [[9,1,3]] Shor code[Shor] functions by concatenating each qubit of a phase-flip with a bit-flip repetition code, allowing it to correct both types of errors at the same time. We can define a Shor code instance by ShorCode.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"shor = ShorCode()\nst = stabilizers(shor)","category":"page"},{"location":"generated/codes/#Steane-Code","page":"QEC Codes","title":"Steane Code","text":"","category":"section"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"The [[7,1,3]] Steane is constructed using the classical binary [7,4,3] Hamming code[Steane]. We can define a Steane code instance by SteaneCode.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"(Image: )","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"steane = SteaneCode()\nst = stabilizers(steane)","category":"page"},{"location":"generated/codes/#[[8,3,2]]-Code","page":"QEC Codes","title":"[[8,3,2]] Code","text":"","category":"section"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"The [[8,3,2]] CSS code is the smallest non-trivial 3D color code[Menendez][Code832]. We can define a CSS [[8,3,2]] code instance by Code832.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"(Image: )","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"code832 = Code832()\nst = stabilizers(code832)","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"[Kitaev]: Kitaev, A. Y. Fault-Tolerant Quantum Computation by Anyons. Annals of Physics 2003, 303 (1), 2–30. https://doi.org/10.1016/S0003-4916(02)00018-0.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"[Menendez]: Menendez, D. H.; Ray, A.; Vasmer, M. Implementing Fault-Tolerant Non-Clifford Gates Using the [[8,3,2]] Color Code. arXiv September 15, 2023. http://arxiv.org/abs/2309.08663.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"[Code832]: THE SMALLEST INTERESTING COLOUR CODE","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"[Shor]: Shor, P. W. (1995). Scheme for reducing decoherence in quantum computer memory. Physical Review A, 52(4), R2493–R2496. https://doi.org/10.1103/PhysRevA.52.R2493","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"[Steane]: Steane, A. (1997). Multiple-particle interference and quantum error correction. Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences, 452(1954), 2551–2577. https://doi.org/10.1098/rspa.1996.0136","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"EditURL = \"../../../examples/table.jl\"","category":"page"},{"location":"generated/table/#Inference-with-Truth-Table","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"","category":"section"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"This example demonstrates how to define stabilizers, encode data qubits measure syndromes, use truth table to infer error type and position, and correct the error.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"We take the [[7,1,3]] Steane code as an example. We use Yao.jl to simulate a physical quantum devise and perform error correction.","category":"page"},{"location":"generated/table/#Definition-of-Stabilizers","page":"Inference with Truth Table","title":"Definition of Stabilizers","text":"","category":"section"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"using TensorQEC, TensorQEC.Yao\nst = stabilizers(SteaneCode())","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"Then we can generate the encoding circuits of the stabilizers by encode_stabilizers. qc is the encoding circuit, data_qubits are the qubits that we should put initial qubtis in, and code is the structure records information of the encoding circuit.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"qc, data_qubits, code = encode_stabilizers(st)\nvizcircuit(qc)","category":"page"},{"location":"generated/table/#Construction-of-the-Truth-Table","page":"Inference with Truth Table","title":"Construction of the Truth Table","text":"","category":"section"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"We can generate the truth table for the error correction by make_table. The truth table is a dictionary, where the key is the syndrome, and the value is the error Pauli string. We can print the truth table by show_table.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"table = make_table(st, 1)\nshow_table(table, 7, 6)","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"We can save the truth table to a file by save_table, and load the truth table from a file by load_table.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"save_table(table, \"test_table.txt\")\ntable2 = load_table(\"test_table.txt\")\ntable == table2","category":"page"},{"location":"generated/table/#Circuit-Simulation-with-Yao.jl","page":"Inference with Truth Table","title":"Circuit Simulation with Yao.jl","text":"","category":"section"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"Create a random qubit state to be encoded.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"reg1 = rand_state(1)","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"We use place_qubits to create a quantum register. data_qubits records the position of data qubits, and the rest ancilla qubits are in the 0rangle state.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"reg = place_qubits(reg1, data_qubits, nqubits(qc))","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"Apply the encoding circuits.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"apply!(reg, qc)","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"Apply an X error on the third qubit.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"apply!(reg, put(7, 5 => X))","category":"page"},{"location":"generated/table/#Measure-the-Syndrome-and-Inference-the-Error-Type-and-Position","page":"Inference with Truth Table","title":"Measure the Syndrome and Inference the Error Type and Position","text":"","category":"section"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"We first measure the stabilizers to get the error syndrome by measure_syndrome!. 1 means the stabilizer is not violated, and -1 means the stabilizer is violated.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"measure_outcome = measure_syndrome!(reg, st)","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"The measrue outcome shows that the stabilizer 4 and 6 are violated. According to the truth table, the error is X_5, which is exactly the error we applied.","category":"page"},{"location":"generated/table/#Error-Correction","page":"Inference with Truth Table","title":"Error Correction","text":"","category":"section"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"Then the following error correction is trivial. We apply the error correction.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"apply!(reg, put(7, 5 => X))","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"Measure the stabilizers after error correction to check whether the error is corrected.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"measure_syndrome!(reg, st)","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"And we can calculate the fidelity after error correction to check whether the initial state is recovered.","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"apply!(reg, qc')\nfidelity_after = fidelity(density_matrix(reg, data_qubits), density_matrix(reg1))","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"","category":"page"},{"location":"generated/table/","page":"Inference with Truth Table","title":"Inference with Truth Table","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"EditURL = \"../../../examples/simulation.jl\"","category":"page"},{"location":"generated/simulation/#Measurement-Free-QEC-Simulation-with-Tensor-Network","page":"Measurement-Free QEC","title":"Measurement-Free QEC Simulation with Tensor Network","text":"","category":"section"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"This example demonstrates how to use tensor network to simulate a error correction process. We use the 713 steane code and the measurement-free QEC[Heußen] as an example. There are non-clifford gates in the quantum circuit, so we use tensor network to simulate the process.","category":"page"},{"location":"generated/simulation/#Measurement-Free-Quantum-Error-Correction","page":"Measurement-Free QEC","title":"Measurement-Free Quantum Error Correction","text":"","category":"section"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Traditional quantum error correction involves several key procedures. First, the encoding procedure involves mapping the logical quantum information into a larger, redundant quantum state using QEC codes such as the Shor code or the surface code. Usually, those quantum code are defined by stabilizers. Then, the syndrome extraction is the process that we extract the value of the stabilizers into ancilla qubits. And we measure the ancilla qubits to detect the value of stabilizers. After detection, the error syndromes are identified, which indicates the presence and location of errors in the quantum state. Next, the error correction procedure uses quantum gates to apply operations that reverse the effects of errors, effectively restoring the quantum state to its original form.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"In the measurement-free QEC protocol, we embed the classical truth table of the error correction into the quantum circuit directly. For example, if we measure the stabilizer 1 and 2 to ancilla qubit 1 and 2, and if they are both in state 1rangle, we know that there is an X error on the first qubit. We can encode this information into the quantum circuit directly by a multi-controlled-X gate.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"(Image: )","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Since such multi-controlled gate is non-clifford, we can't simulate it with clifford circuit simulator.","category":"page"},{"location":"generated/simulation/#Definition-of-Stabilizers-and-Encoding-Circuits","page":"Measurement-Free QEC","title":"Definition of Stabilizers and Encoding Circuits","text":"","category":"section"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"using TensorQEC, TensorQEC.Yao\nusing TensorQEC.OMEinsum\nst = stabilizers(SteaneCode())","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Generate the encoding circuits of the stabilizers by encode_stabilizers. qcen is the encoding circuit, data_qubits are the qubits that we should put initial qubtis in, and code is the structure records information of the encoding circuit.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"qcen, data_qubits, code = encode_stabilizers(st)\nvizcircuit(qcen)","category":"page"},{"location":"generated/simulation/#Syndrome-Extraction-and-Measurement-Free-Error-Correction","page":"Measurement-Free QEC","title":"Syndrome Extraction and Measurement-Free Error Correction","text":"","category":"section"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"First, we generate the steane measurement circuit by measure_circuit_steane and st_pos records the ancilla qubits that store the measurement results of the stabilizers.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"qcm,st_pos, num_qubits = measure_circuit_steane(qcen,data_qubits[1],st,3)\nvizcircuit(qcm)","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Then we generate truth table for the error correction by make_table. For more detials on truth table, please check Inference with Truth Table.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"table = make_table(st, 1)\nshow_table(table,7,6)","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Now we use correct_circuit to generate the measurement-free correction circuit by encoding the truth table on the quantum circuit directly.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"qccr = correct_circuit(table, collect(st_pos), num_qubits, 6, 7)\nvizcircuit(qccr)","category":"page"},{"location":"generated/simulation/#Circuit-Simulation-with-Tensor-Networks","page":"Measurement-Free QEC","title":"Circuit Simulation with Tensor Networks","text":"","category":"section"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"We connect the encoding circuit, the measurement circuit, and the correction circuit to form a full circuit. And we apply a Y error on the third qubit after encoding.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"qcf=chain(subroutine(num_qubits, qcen, 1:7),put(27,3=>Y),qcm,qccr,subroutine(num_qubits, qcen', 1:7))\nvizcircuit(qcf)","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Then we transform the circuit to a tensor network and optimize its contraction order. QCInfo records the information of the quantum circuit, including the data qubits and the number of qubits. fidelity_tensornetwork constructs the tensor network to calculate the fidelity after error correction.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"tn = fidelity_tensornetwork(qcf, QCInfo(data_qubits, 27))","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Finally, we optimize the contraction order and contract the tensor network to get the infidelity after error correction.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"optnet = optimize_code(tn, TreeSA(; ntrials=1, niters=5), OMEinsum.MergeVectors())\ninf = 1-abs(contract(optnet)[1]/4)","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"[Heußen]: Heußen, S., Locher, D. F., & Müller, M. (2024). Measurement-Free Fault-Tolerant Quantum Error Correction in Near-Term Devices. PRX Quantum, 5(1), 010333. https://doi.org/10.1103/PRXQuantum.5.010333","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TensorQEC","category":"page"},{"location":"#TensorQEC","page":"Home","title":"TensorQEC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package utilizes the tensor network to study the properties of quantum error correction(QEC). The main features include","category":"page"},{"location":"","page":"Home","title":"Home","text":"Quantum error correction code decoder with tensor network (Inference with Tensor Network),\nQuantum circuit simulation with tensor network to estimate the threshold of QEC.","category":"page"},{"location":"#TODO:Drawbacks","page":"Home","title":"TODO:Drawbacks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Also, we include more general QEC tools, including","category":"page"},{"location":"","page":"Home","title":"Home","text":"Commonly used QEC code stabilizer generators,\nQEC code distance calculation,\nQEC encoding circuit construction,\nDecoding truth table construction,\nMeasurement circuit construction.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"EditURL = \"../../../examples/inference.jl\"","category":"page"},{"location":"generated/inference/#Inference-with-Tensor-Network","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"","category":"section"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"This example demonstrates how to define stabilizers, encode data qubits measure syndromes, use tensor network to infer error probability, and correct the error. The main reference is [Ferris].","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"We take the 3*3 surface code as an example. We use Yao.jl to simulate a physical quantum devise and perform error correction.","category":"page"},{"location":"generated/inference/#Definition-of-Stabilizers","page":"Inference with Tensor Network","title":"Definition of Stabilizers","text":"","category":"section"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"using TensorQEC, TensorQEC.Yao\nst = stabilizers(SurfaceCode(3,3))","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Then we can generate the encoding circuits of the stabilizers by encode_stabilizers. qc is the encoding circuit, data_qubits are the qubits that we should put initial qubtis in, and code is the structure records information of the encoding circuit.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"qc, data_qubits, code = encode_stabilizers(st)\nvizcircuit(qc)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"During the process of getting the encoding circuit, we may adjust the generators of the stabilizer group. The current generators are","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"TensorQEC.bimatrix2stabilizers(code)","category":"page"},{"location":"generated/inference/#Circuit-Simulation-with-Yao.jl","page":"Inference with Tensor Network","title":"Circuit Simulation with Yao.jl","text":"","category":"section"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Create a random qubit state to be encoded.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"reg1 = rand_state(1)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"We use place_qubits to create a quantum register. data_qubits records the position of data qubits, and the rest ancilla qubits are in the 0rangle state.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"reg = place_qubits(reg1, data_qubits, nqubits(qc))","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Apply the encoding circuits.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"apply!(reg, qc)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Apply an X error on the third qubit.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"apply!(reg, put(9, 3 => X))","category":"page"},{"location":"generated/inference/#Measure-the-Syndrome-and-Inference-the-Error-Probability","page":"Inference with Tensor Network","title":"Measure the Syndrome and Inference the Error Probability","text":"","category":"section"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"We first measure the stabilizers to get the error syndrome by measure_syndrome!. 1 means the stabilizer is not violated, and -1 means the stabilizer is violated. Though the stabilizers are not the same as the initial stabilizers, we can't directly measure the current stabilizers to get the syndrome. The reason is that there may be some long range term in the current stabilizers, which can' be measrued physically. So we still measure the initial stabilizers to get the syndrome.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"measure_outcome = measure_syndrome!(reg, st)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Then we transform the syndrome in the current stabilizers by transformed_sydrome_dict. The syndrome is transformed to 0 if the measurement outcome is 1, and 1 if the measurement outcome is -1.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"syn_dict = transformed_sydrome_dict(measure_outcome, code)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Now we generate the tensor network for syndrome inference by clifford_network.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"cl = clifford_network(qc)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Define the prior error probability of each physical qubit. Here we assume the error probability of each qubit is the same. There are probability of 85% that the qubits are correct, and 5% that there is an X error, Y error, or Z error respectively.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"p = fill([0.85, 0.05, 0.05, 0.05], 9)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"We can use the syndrome_inference function to infer the error probability.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"pinf = syndrome_inference(cl, syn_dict, p)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Generate the Pauli string for error correction. correction_pauli_string generates the error Pauli string in the coding space. To correct the error, we still need to transform it to the physical space by pauli_string_map_iter. The corretion pauli string here is X_6. Since there is a stabilizer X_3X_6, applying X_3 or X_6 on the coding space are equivalent.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"ps_ec_phy = pauli_string_map_iter(correction_pauli_string(9, syn_dict, pinf), qc)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Or we can simply use the inference function to infer error pauli string in one function.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"ps_ec_phy = inference(measure_outcome, code, qc, p)","category":"page"},{"location":"generated/inference/#Error-Correction","page":"Inference with Tensor Network","title":"Error Correction","text":"","category":"section"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Apply the error correction.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"apply!(reg, Yao.YaoBlocks.Optimise.to_basictypes(ps_ec_phy))","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Finally, we can measure the stabilizers after error correction to check whether the error is corrected.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"measure_syndrome!(reg, st)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"And we can calculate the fidelity after error correction to check whether the initial state is recovered.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"apply!(reg, qc')\nfidelity_after = fidelity(density_matrix(reg, data_qubits), density_matrix(reg1))","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"[Ferris]: Ferris, A. J.; Poulin, D. Tensor Networks and Quantum Error Correction. Phys. Rev. Lett. 2014, 113 (3), 030501. https://doi.org/10.1103/PhysRevLett.113.030501.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"This page was generated using Literate.jl.","category":"page"}]
}
