var documenterSearchIndex = {"docs":
[{"location":"generated/error_model/#Error-Model-and-Syndrome-Extraction","page":"Error Model and Syndrome Extraction","title":"Error Model and Syndrome Extraction","text":"","category":"section"},{"location":"generated/error_model/#Error-Model","page":"Error Model and Syndrome Extraction","title":"Error Model","text":"","category":"section"},{"location":"generated/error_model/","page":"Error Model and Syndrome Extraction","title":"Error Model and Syndrome Extraction","text":"We have 2 types of error models. IndependentFlipError is for the case that the error model is independent flip error. IndependentDepolarizingError is the error model for the case that the error model is independent depolarizing error. We can use iid_error to easily generate an independent and identically distributed error model.","category":"page"},{"location":"generated/error_model/","page":"Error Model and Syndrome Extraction","title":"Error Model and Syndrome Extraction","text":"using TensorQEC\niide = iid_error(0.05,0.05,0.05,7)","category":"page"},{"location":"generated/error_model/","page":"Error Model and Syndrome Extraction","title":"Error Model and Syndrome Extraction","text":"We can generate a random error pattern with random_error_qubits.","category":"page"},{"location":"generated/error_model/","page":"Error Model and Syndrome Extraction","title":"Error Model and Syndrome Extraction","text":"for _ in 1:10\n    print(random_error_qubits(iide))\nend","category":"page"},{"location":"generated/error_model/","page":"Error Model and Syndrome Extraction","title":"Error Model and Syndrome Extraction","text":"This is the same for IndependentFlipError.","category":"page"},{"location":"generated/error_model/","page":"Error Model and Syndrome Extraction","title":"Error Model and Syndrome Extraction","text":"random_error_qubits(iid_error(0.3,7))","category":"page"},{"location":"generated/error_model/#Syndrome-Extraction","page":"Error Model and Syndrome Extraction","title":"Syndrome Extraction","text":"","category":"section"},{"location":"generated/error_model/","page":"Error Model and Syndrome Extraction","title":"Error Model and Syndrome Extraction","text":"First, we define a Tanner graph and a error pattern.","category":"page"},{"location":"generated/error_model/","page":"Error Model and Syndrome Extraction","title":"Error Model and Syndrome Extraction","text":"tanner = CSSTannerGraph(SteaneCode())\nusing Random;Random.seed!(123)\nerror_qubits = random_error_qubits(iide)","category":"page"},{"location":"generated/error_model/","page":"Error Model and Syndrome Extraction","title":"Error Model and Syndrome Extraction","text":"Then, we can extract the syndrome from the error pattern with syndrome_extraction.","category":"page"},{"location":"generated/error_model/","page":"Error Model and Syndrome Extraction","title":"Error Model and Syndrome Extraction","text":"syndrome = syndrome_extraction(error_qubits, tanner)","category":"page"},{"location":"generated/error_model/","page":"Error Model and Syndrome Extraction","title":"Error Model and Syndrome Extraction","text":"","category":"page"},{"location":"generated/error_model/","page":"Error Model and Syndrome Extraction","title":"Error Model and Syndrome Extraction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/inference/#Inference-with-Tensor-Network","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"","category":"section"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"This example demonstrates how to define stabilizers, encode data qubits measure syndromes, and use tensor network to infer the most likely error[Ferris].","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"We take the 3times 3 surface code as an example, and use Yao.jl to verify the error correction circuit.","category":"page"},{"location":"generated/inference/#Definition-of-Stabilizers","page":"Inference with Tensor Network","title":"Definition of Stabilizers","text":"","category":"section"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"using TensorQEC, TensorQEC.Yao\nsurface_stabilizers = stabilizers(SurfaceCode(3,3))","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Then we can generate the encoding circuits of the stabilizers by encode_stabilizers.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"encoder, data_qubits, bimatrix = encode_stabilizers(surface_stabilizers)\nvizcircuit(encoder)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"where encoder is the encoding circuit, data_qubits are the qubits that we should put initial qubtis in, and bimatrix is a CSSBimatrix instance that records information of the encoding circuit. For more details on Bimatrix, please check [Gottesman].","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"The process of obtaining the encoding circuit requires adjusting the generators of the stabilizer group. The new generators are","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"TensorQEC.bimatrix2stabilizers(bimatrix)","category":"page"},{"location":"generated/inference/#Circuit-Simulation-with-Yao.jl","page":"Inference with Tensor Network","title":"Circuit Simulation with Yao.jl","text":"","category":"section"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Create a random qubit state to be encoded.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"data = rand_state(1)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"We use place_qubits to create a quantum register. data_qubits records the position of data qubits, and the rest ancilla qubits are in the 0rangle state.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"logic_state = place_qubits(data, data_qubits, nqubits(encoder))","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Apply the encoding circuits.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"apply!(logic_state, encoder)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Apply an X error on the third qubit.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"apply!(logic_state, put(9, 3 => X))","category":"page"},{"location":"generated/inference/#Measure-the-Syndrome-and-Inference-the-Error-Probability","page":"Inference with Tensor Network","title":"Measure the Syndrome and Inference the Error Probability","text":"","category":"section"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"We first measure the stabilizers to get the error syndrome by measure_syndrome!. 1 means the stabilizer is not violated, and -1 means the stabilizer is violated. Though the stabilizers are not the same as the initial stabilizers, we can't directly measure the current stabilizers to get the syndrome. The reason is that there may be some long range term in the current stabilizers, which can' be measrued physically. So we still measure the initial stabilizers to get the syndrome.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"measure_outcome = measure_syndrome!(logic_state, surface_stabilizers)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Then we transform the syndrome in the current stabilizers by transformed_syndrome_dict. The syndrome is transformed to 0 if the measurement outcome is 1, and 1 if the measurement outcome is -1.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"syn_dict = transformed_syndrome_dict(measure_outcome, bimatrix)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Now we generate the tensor network for syndrome inference by clifford_network.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"tensor_network = clifford_network(encoder)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Define the prior error probability of each physical qubit. Here we assume the error probability of each qubit is the same. There are probability of 85% that the qubits are correct, and 5% that there is an X error, Y error, or Z error respectively.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"prior = fill([0.85, 0.05, 0.05, 0.05], 9)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"We can use the syndrome_inference function to infer the error probability.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"pinf = syndrome_inference(tensor_network, syn_dict, prior)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Generate the Pauli string for error correction. correction_pauli_string generates the error Pauli string in the coding space. To correct the error, we still need to transform it to the physical space by clifford_simulate. The corretion pauli string here is X_6. Since there is a stabilizer X_3X_6, applying X_3 or X_6 on the coding space are equivalent.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"ps_ec_phy = clifford_simulate(correction_pauli_string(9, syn_dict, pinf), encoder).output","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Or we can simply use the inference function to infer error pauli string in one function.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"ps_ec_phy = inference(measure_outcome, bimatrix, encoder, prior)","category":"page"},{"location":"generated/inference/#Error-Correction","page":"Inference with Tensor Network","title":"Error Correction","text":"","category":"section"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Apply the error correction by converting the Pauli string to Yao block with yaoblock.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"apply!(logic_state, yaoblock(ps_ec_phy))","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"Finally, we can measure the stabilizers after error correction to check whether the error is corrected.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"measure_syndrome!(logic_state, surface_stabilizers)","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"And we can calculate the fidelity after error correction to check whether the initial state is recovered.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"apply!(logic_state, encoder')\nfidelity_after = fidelity(density_matrix(logic_state, data_qubits), density_matrix(data))","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"[Ferris]: Ferris, A. J.; Poulin, D. Tensor Networks and Quantum Error Correction. Phys. Rev. Lett. 2014, 113 (3), 030501. https://doi.org/10.1103/PhysRevLett.113.030501.","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"[Gottesman]: Gottesman, D. (1997). Stabilizer Codes and Quantum Error Correction (arXiv:quant-ph/9705052). arXiv. http://arxiv.org/abs/quant-ph/9705052","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"","category":"page"},{"location":"generated/inference/","page":"Inference with Tensor Network","title":"Inference with Tensor Network","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/coherent/#Coherent-Error-Simulation","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"","category":"section"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"Coherent error or unitary error is a type of error that can be described by a unitary matrix acting on the quantum state. For example, if we want to apply an unitary U on the state, however, we apply a unitary U instead, which differ from U slighty. The error can be described by an unitary E = UU^dagger acting on the quantum state. Usually, this unitary is non-Clifford, thus it is hard to simulate with the stabilizer formalism. Here, we use tensor network to simulate a quantum circuit with coherent error.","category":"page"},{"location":"generated/coherent/#Quantum-Circuit-Construction","page":"Coherent Error Simulation","title":"Quantum Circuit Construction","text":"","category":"section"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"First, we define the stabilizers for Steane code.","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"using TensorQEC, TensorQEC.Yao\nusing TensorQEC.OMEinsum\nst = stabilizers(SteaneCode())","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"Then we generate the encoding circuits of the stabilizers by encode_stabilizers. qc is the encoding circuit, data_qubits are the qubits that we should put initial qubtis in, and code is the structure records information of the encoding circuit.","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"qcen, data_qubits, code = encode_stabilizers(st)\nvizcircuit(qcen)","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"Now we construct a 7-qubit quantum circuit to perform the following operations:","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"Encoding the initial state with the encoding circuit.\nApply an logical X gate which consists of three X gates on the seven qubits.\nDecoding the state with the encoding circuit.\nApply an X gate to recover the initial state.","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"qc = chain(qcen)\npush!(qc, [put(7, i => X) for i in 1:7]...)\npush!(qc, qcen')\npush!(qc, put(7, 6 => X))\nvizcircuit(qc)","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"This circuit should act trivially on the data qubit. We will check this later.","category":"page"},{"location":"generated/coherent/#Circuit-Simulation-with-Tensor-Networks","page":"Coherent Error Simulation","title":"Circuit Simulation with Tensor Networks","text":"","category":"section"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"Simulating quantum circuits using tensor networks is a powerful technique, particularly for circuits that are not easily amenable to simulation with classical computers[Markov]. We can replace gates and density matries by tensors to get the tensor network representation of the quantum circuit. Applying a quantum channel on a density matix is equivalent to connecting two tensors together and contracting them. (Image: )","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"To trace out a matrix in the tensor network, we can simply connect the two indices of the matrix and contract them. To partially trace out the ancilla qubits, we can simply connect the output indices of the ancilla qubits and contract them. (Image: )","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"We can use the function simulation_tensornetwork to generate the tensor network of the quantum channel.","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"tn,input_indices,output_indices = simulation_tensornetwork(qc, QCInfo(data_qubits, 7))","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"And we contract the tensor network to get the matrix representation of the quantum channel, which is an identity channel.","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"optnet = optimize_code(tn, TreeSA(; ntrials=1, niters=3), OMEinsum.MergeVectors())\nmatr = contract(optnet)","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"Also we can compute the circuit fidelity with identity channel directly by connecting the input and output indices of the quantum channel and contracting them. (Image: )","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"fidelity_tensornetwork transforms the circuit to a tensor network to calculate fidelity.","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"tn = fidelity_tensornetwork(qc, QCInfo(data_qubits, 7))\noptnet = optimize_code(tn, TreeSA(; ntrials=1, niters=3), OMEinsum.MergeVectors())\ninfidelity = 1 - abs(contract(optnet)[1])","category":"page"},{"location":"generated/coherent/#Coherent-Error-Simulation-with-Tensor-Network","page":"Coherent Error Simulation","title":"Coherent Error Simulation with Tensor Network","text":"","category":"section"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"We add coherent error to the circuit by adding unitary error to every unitary gate by error_quantum_circuit, which replaces the gates in the original circuit with the errored gates.","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"eqc = error_quantum_circuit(qc, 1e-5)\nvizcircuit(eqc)","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"Finally, we can check the infidelity after the circuit with coherent error.","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"tn = fidelity_tensornetwork(eqc, QCInfo(data_qubits, 7))\noptnet = optimize_code(tn, TreeSA(; ntrials=1, niters=3), OMEinsum.MergeVectors())\ninfidelity = 1 - abs(contract(optnet)[1])","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"[Markov]: Markov, I. L., & Shi, Y. (2008). Simulating Quantum Computation by Contracting Tensor Networks. SIAM Journal on Computing, 38(3), 963–981. https://doi.org/10.1137/050644756","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"","category":"page"},{"location":"generated/coherent/","page":"Coherent Error Simulation","title":"Coherent Error Simulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"performancetips/#Performance-Tips","page":"Performance Tips","title":"Performance Tips","text":"","category":"section"},{"location":"performancetips/#Multiprocessing","page":"Performance Tips","title":"Multiprocessing","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Submodule TensorQEC.SimpleMutiprocessing provides one function TensorQEC.SimpleMultiprocessing.multiprocess_run function for simple multi-processing jobs. It is not directly related to TensorQEC, but is very convenient to have one. Suppose we want to decode 9 times 9 surface code for 10 different error syndromes with 4 processes. We can create a file, e.g. named run.jl with the following content","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"using Distributed, TensorQEC.SimpleMultiprocessing\nusing Random, TensorQEC  # to avoid multi-precompilation\n@everywhere using Random, TensorQEC\n\nresults = multiprocess_run(collect(1:10)) do seed\n    Random.seed!(seed)\n    d = 9\n    @info \"$d x $d SurfaceCode, error seed= $seed\"\n    decoder = IPDecoder()\n    tanner = CSSTannerGraph(SurfaceCode(d, d))\n    em = DepolarizingError(0.05, 0.06, 0.1)\n    ep = random_error_qubits(d*d, em)\n    syn = syndrome_extraction(ep,tanner)\n    res = decode(decoder,tanner,syn)\n    return check_logical_error(ep.xerror, res.xerror_qubits, tanner.stgx.H) && check_logical_error(ep.zerror, res.zerror_qubits, tanner.stgz.H)\nend\n\nprintln(results)","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"One can run this script file with the following command","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"$ julia -p4 run.jl\n      From worker 4:    [ Info: running argument 4 on device 4\n      From worker 2:    [ Info: running argument 3 on device 2\n      From worker 2:    [ Info: 9 x 9 SurfaceCode, error seed= 3\n      From worker 3:    [ Info: running argument 1 on device 3\n      From worker 3:    [ Info: 9 x 9 SurfaceCode, error seed= 1\n      From worker 4:    [ Info: 9 x 9 SurfaceCode, error seed= 4\n      From worker 5:    [ Info: running argument 2 on device 5\n      From worker 5:    [ Info: 9 x 9 SurfaceCode, error seed= 2\n      From worker 3:    [ Info: running argument 5 on device 3\n      From worker 3:    [ Info: 9 x 9 SurfaceCode, error seed= 5\n      ...\n    Any[false, true, true, true, false, true, true, true, false, false]","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"You will see a vector of decoding results printed out, where true means there is no logical error according to the decoding result.","category":"page"},{"location":"generated/decoder/#Decoder-Interface","page":"Decoder Interface","title":"Decoder Interface","text":"","category":"section"},{"location":"generated/decoder/#Decoding-Problems","page":"Decoder Interface","title":"Decoding Problems","text":"","category":"section"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"We have 3 types of decoding problems. ClassicalDecodingProblem is for the case that the error model is independent flip error. IndependentDepolarizingDecodingProblem is the decoding problem for the case that the error model is independent depolarizing error. GeneralDecodingProblem is the decoding problem for the case that error model on different qubits are correlated. We use a tensor network to represent the error probability distribution. Here is an example of how to construct a decoding problem.","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"using TensorQEC\ntanner = CSSTannerGraph(SurfaceCode(3,3))\nproblem = IndependentDepolarizingDecodingProblem(tanner,iid_error(0.05,0.05,0.05,9))","category":"page"},{"location":"generated/decoder/#Decoding-Process","page":"Decoder Interface","title":"Decoding Process","text":"","category":"section"},{"location":"generated/decoder/#Decoders","page":"Decoder Interface","title":"Decoders","text":"","category":"section"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"There are 2 types of decoders. AbstractClassicalDecoder and AbstractGeneralDecoder solve ClassicalDecodingProblem and GeneralDecodingProblem, respectively. For IndependentDepolarizingDecodingProblem, we can transfer it to GeneralDecodingProblem and use AbstractGeneralDecoder to solve it. Also, for an IndependentDepolarizingDecodingProblem of a CSS code, we can transfer it to two ClassicalDecodingProblem and use AbstractClassicalDecoder to solve them. Here is a list of supported decoders.","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"Decoder API Classification\nMinimum Weight Perfect Matching [Dennis][Higgott] MatchingDecoder AbstractClassicalDecoder\nBelief Propagation [Yao] BPDecoder AbstractClassicalDecoder\nLookup Table TableDecoder AbstractGeneralDecoder\nInteger Programming [Landahl] IPDecoder AbstractGeneralDecoder\nTensor Network Decoders [Chubb] TNMAP AbstractGeneralDecoder","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"Here we use the integer programming decoder to solve the decoding problem.","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"decoder = IPDecoder()","category":"page"},{"location":"generated/decoder/#Compilation","page":"Decoder Interface","title":"Compilation","text":"","category":"section"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"Usually, we use decoders to run monte carlo simulations to estimate the code capacity. We use the same decoder to solve the decoding problem of the same QEC code and error model for different error and syndrome configurations. Ones the error model and the QEC code are fixed, we can compile the decoder to avoid the overhead of decoding. For example, in Lookup Table decoder, we can make the truth table once and use it for all the decoding problems. And in tensor network decoders, we can make the tensor network once and connect it to different syndrome configurations when decoding. This is also the reason why there is no syndrome information in the decoding problem or in the decoder.","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"compiled_decoder = compile(decoder, problem);\nnothing #hide","category":"page"},{"location":"generated/decoder/#Decoding","page":"Decoder Interface","title":"Decoding","text":"","category":"section"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"Now we randomly generate an error configuration.","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"using Random\nRandom.seed!(123)\nerror_qubits = random_error_qubits(problem.pvec)","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"The corresponding syndrome is","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"syndrome = syndrome_extraction(error_qubits, tanner)","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"We can use the compiled decoder to decode the syndrome with decode. The decoding result is a DecodingResult object.","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"res = decode(compiled_decoder, syndrome)","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"We can check the result by comparing the syndrome of the decoding result.","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"syndrome == syndrome_extraction(res.error_qubits, tanner)","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"Also, to check wether there is a logical error, we can first generate the logical operators with logical_operator.","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"logicalx_operators,logicalz_operators = logical_operator(tanner)","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"Then we can check the syndrome of the logical operators with check_logical_error.","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"check_logical_error(error_qubits, res.error_qubits, logicalx_operators, logicalz_operators)","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"Simply decode function can also be used to decode the syndrome. The compilation step is contained in the function.","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"decode(decoder,problem,syndrome)","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"[Dennis]: Dennis, E.; Kitaev, A.; Landahl, A.; Preskill, J. Topological Quantum Memory. Journal of Mathematical Physics 2002, 43 (9), 4452–4505. https://doi.org/10.1063/1.1499754.","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"[Higgott]: Higgott, O.; Gidney, C. Sparse Blossom: Correcting a Million Errors per Core Second with Minimum-Weight Matching. Quantum 2025, 9, 1600. https://doi.org/10.22331/q-2025-01-20-1600.","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"[Yao]: Yao, H.; Laban, W. A.; Häger, C.; Amat, A. G. i; Pfister, H. D. Belief Propagation Decoding of Quantum LDPC Codes with Guided Decimation. arXiv June 21, 2024. http://arxiv.org/abs/2312.10950 (accessed 2024-10-31).","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"[Landahl]: Landahl, A. J.; Anderson, J. T.; Rice, P. R. Fault-Tolerant Quantum Computing with Color Codes. arXiv August 29, 2011. https://doi.org/10.48550/arXiv.1108.5738.","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"[Chubb]: (1) Chubb, C. T. General Tensor Network Decoding of 2D Pauli Codes. arXiv October 13, 2021. https://doi.org/10.48550/arXiv.2101.04125.","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"","category":"page"},{"location":"generated/decoder/","page":"Decoder Interface","title":"Decoder Interface","text":"This page was generated using Literate.jl.","category":"page"},{"location":"clifford/#Pauli-Basis-and-Clifford-group","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"","category":"section"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"In this section, we introduce the definition of Pauli strings and basic operations on them. We also introduce the Clifford group and how to simulate a Clifford circuit applied on Pauli strings.","category":"page"},{"location":"clifford/#Pauli-Strings","page":"Pauli Basis and Clifford group","title":"Pauli Strings","text":"","category":"section"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"A pauli string is a tensor product of Pauli operators acting on different qubits. PauliString is a subtype of [CompositeBlock] with a field ids storing the Pauli operators. We can define pauli string with PauliString or @P_str string literal.","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"using TensorQEC, TensorQEC.Yao\nPauliString(Pauli(1), Pauli(0), Pauli(3), Pauli(2)) # X_1Z_3Y_4\nPauliString(4, (1, 2, 4)=>Pauli(1)) # X_1X_2X_4\nP\"XZZ\"","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"Note that the printed Pauli string is in big-endian order, i.e. the first Pauli operator is the leftmost one. We can check if two Pauli strings commute or anticommute with iscommute and isanticommute.","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"p1 = PauliString(5, (1,2)=>Pauli(1))\np2 = PauliString(5, (1,2)=>Pauli(3))\niscommute(p1, p2)","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"We can use Yao.mat to get the matrix representation of a Pauli string.","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"mat(ComplexF64, P\"XZ\") # X_1Z_2","category":"page"},{"location":"clifford/#Pauli-Basis","page":"Pauli Basis and Clifford group","title":"Pauli Basis","text":"","category":"section"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"pauli_basis generates all the Pauli strings of a given length. Those Pauli strings are stored in a high-dimensional array.","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"pauli_basis(2)","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"pauli_decomposition returns the coefficients of a matrix in the Pauli basis.","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"pauli_decomposition(ConstGate.CNOT)","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"That implies that mathrmCNOT = frac12 (I otimes I + I otimes X + Z otimes I - Z otimes X). We can check this by","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"# Note: `Yao.kron` has an inversed order of the arguments compared to `LinearAlgebra.kron`.\n0.5*(mat(kron(I2,I2) + kron(I2,X) + kron(Z,I2) - kron(Z,X))) ≈ mat(ConstGate.CNOT)","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"pauli_repr returns the matrix representation of a quantum gate in the Pauli basis. For Hadamard gate H, we know that HIH = I HXH = Z HYH = -Y HZH = X. We can convert H into the Pauli basis.","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"pauli_repr(H)","category":"page"},{"location":"clifford/#Clifford-Group","page":"Pauli Basis and Clifford group","title":"Clifford Group","text":"","category":"section"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"Clifford group is the set of all permutations of Pauli group, i.e. the pauli_repr of its elements are \"permutation matrices\" with phases. It can be generated by Hadamard gate, S gate and CNOT gate[Bravyi2022]. We can use TensorQEC.clifford_group to generate the Clifford group.","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"TensorQEC.clifford_group(1)","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"Each element in the Clifford group acts on pauli basis as a permutation matrix. For n= 1 2, and 3, this group contains 24, 11520, and 92897280 elements, respectively. We can use CliffordGate to convert a Yao gate into a Clifford gate, which is characterized by a permutation (with phases) of Pauli basis.","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"pm = CliffordGate(H)","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"With the permutation matrix representation, we can efficienlly simulate a Clifford circuit. We first show how to apply a Clifford gate to a Pauli string by perm_of_paulistring. Here we apply the Hadamard gate to the second qubit of Pauli string I_1X_2 and get I_1Z_2 with a phase 1.","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"ps1 = P\"IX\"  # same as: PauliString(Pauli(0), Pauli(1))\nps2, phase = perm_of_paulistring(ps1, (2,)=>pm)\nps1, ps2, phase","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"Put those all together, we can apply a Clifford circuit to a Pauli string by clifford_simulate.","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"qc = chain(put(5, 1 => H), control(5, 1, 2 => Z), control(5, 3, 4 => X), control(5, 5, 3 => X), put(5, 1 => X))\nvizcircuit(qc)","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"Apply the circuit to Pauli string Z_1Y_2I_3Y_4X_5, we get Y_1X_2Y_3Y_4Y_5 with a phase 1.","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"ps = P\"ZYIYX\"\nres = clifford_simulate(ps, qc)\nps2 = res.output","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"where res.output is the Pauli string after the Clifford circuit and res.phase is the phase factor. It corresponds to the following quantum circuit.","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"clifford_simulation_circuit = chain(qc', yaoblock(ps), qc)\nCircuitStyles.barrier_for_chain[] = true  # setup barrier for better visualization\nvizcircuit(clifford_simulation_circuit)","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"Here, we use yaoblock to convert the Pauli string to a Yao block.","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"We can check the result by","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"CircuitStyles.barrier_for_chain[] = false  # disable barrier\nres.phase * mat(clifford_simulation_circuit) ≈ mat(yaoblock(ps2))","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"We can also visualize the history of Pauli strings by annotate_history.","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"annotate_history(res)","category":"page"},{"location":"clifford/","page":"Pauli Basis and Clifford group","title":"Pauli Basis and Clifford group","text":"[Bravyi2022]: Bravyi, S., Latone, J.A., Maslov, D., 2022. 6-qubit optimal Clifford circuits. npj Quantum Inf 8, 1–12. https://doi.org/10.1038/s41534-022-00583-7","category":"page"},{"location":"man/","page":"Manual","title":"Manual","text":"Documentation for TensorQEC.","category":"page"},{"location":"man/","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"man/#TensorQEC.AbstractDecoder","page":"Manual","title":"TensorQEC.AbstractDecoder","text":"AbstractDecoder\n\nThe abstract type for a decoder.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.AbstractDecodingProblem","page":"Manual","title":"TensorQEC.AbstractDecodingProblem","text":"AbstractDecodingProblem\n\nThe abstract type for a decoding problem.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.AbstractPauli","page":"Manual","title":"TensorQEC.AbstractPauli","text":"AbstractPauli{N}\n\nAn abstract type for Pauli operators, where N is the number of qubits.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.AbstractSyndrome","page":"Manual","title":"TensorQEC.AbstractSyndrome","text":"AbstractSyndrome\n\nAbstract type for syndrome, which is basically a vector of bits.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.AbstractTannerGraph","page":"Manual","title":"TensorQEC.AbstractTannerGraph","text":"AbstractTannerGraph\n\nAbstract type for Tanner graphs, which is a bipartite graph that represents a classical linear code.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.BPDecoder","page":"Manual","title":"TensorQEC.BPDecoder","text":"BPDecoder(bp_max_iter::Int = 100, osd::Bool = true)\n\nBelief propagation decoder.\n\nFields:\n\nbp_max_iter::Int: the maximum number of iterations.\nosd::Bool: whether to use osd.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.CSSBimatrix","page":"Manual","title":"TensorQEC.CSSBimatrix","text":"CSSBimatrix\n\nSince the encding process may alter the generators of stabilizer group, we introduce the CSSBimatrix structure to store the information of encoding process. The CSSBimatrix structure contains the following fields\n\nmatrix: The bimatrix representation of the stabilizers.\nQ: The matrix records the Gaussian elimination process, whcih is used to recover the original stabilizers.\nordering: The ordering of qubits.\nxcodenum: The number of X stabilizers.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.CSSErrorPattern","page":"Manual","title":"TensorQEC.CSSErrorPattern","text":"CSSErrorPattern(xerror::Vector{Mod2}, zerror::Vector{Mod2})\n\nA CSS error pattern with X and Z errors. Fields:\n\nxerror::Vector{Mod2}: the X errors\nzerror::Vector{Mod2}: the Z errors\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.CSSTannerGraph","page":"Manual","title":"TensorQEC.CSSTannerGraph","text":"CSSCSSTannerGraph(stgx::SimpleTannerGraph, stgz::SimpleTannerGraph)\nCSSTannerGraph(nq::Int, stxs::Vector{Vector{Int}}, stzs::Vector{Vector{Int}})\nCSSTannerGraph(sts::Vector{PauliString{N}}) where N\nCSSTannerGraph(cqc::CSSQuantumCode)\n\nTwo tanner graph for a CSS code, one for X stabilizers and one for Z stabilizers.\n\nFields\n\nstgx: Tanner graph for X stabilizers\nstgz: Tanner graph for Z stabilizers\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.ClassicalDecodingProblem","page":"Manual","title":"TensorQEC.ClassicalDecodingProblem","text":"ClassicalDecodingProblem(tanner::SimpleTannerGraph, pvec::IndependentFlipError\n\nA classical decoding problem. Fields:\n\ntanner::SimpleTannerGraph: the Tanner graph\npvec::IndependentFlipError: the independent probability distributions on each bit\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.CliffordGate","page":"Manual","title":"TensorQEC.CliffordGate","text":"CliffordGate{PM<:PermMatrixCSC{Int, Int}}\n\nCliffordGate represented as a permutation matrix.\n\nFields\n\nmat::PM: The permutation matrix.\n\nExamples\n\njulia> using TensorQEC.Yao\n\njulia> CliffordGate(H)\nCliffordGate(nqubits = 1)\n I → I\n X → Z\n Y → -Y\n Z → X\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.CliffordSimulateResult","page":"Manual","title":"TensorQEC.CliffordSimulateResult","text":"CliffordSimulateResult{N}\n\nThe result of simulating a Pauli string by a Clifford circuit.\n\nFields\n\noutput::PauliString{N}: A mapped Pauli string as the output.\nphase::ComplexF64: The phase factor.\ncircuit::ChainBlock: The circuit (simplified, with linear structure).\nhistory::Vector{PauliString{N}}: The history of Pauli strings, its length is length(circuit)+1.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.Code1573","page":"Manual","title":"TensorQEC.Code1573","text":"Code1573\n\nConstruct a [[15,7,3]] CSS code instance.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.Code422","page":"Manual","title":"TensorQEC.Code422","text":"Code422\n\nConstruct a [[4,2,2]] CSS code instance.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.Code513","page":"Manual","title":"TensorQEC.Code513","text":"Code513\n\nConstruct a [[5,1,3]] code instance.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.Code832","page":"Manual","title":"TensorQEC.Code832","text":"Code832\n\nConstruct a [[8,3,2]] CSS code instance.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.CompiledDecoder","page":"Manual","title":"TensorQEC.CompiledDecoder","text":"CompiledDecoder\n\nCompile the decoder to specific tanner graph and prior probability distributions.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.DecodingResult","page":"Manual","title":"TensorQEC.DecodingResult","text":"DecodingResult(success_tag::Bool, error_qubits::ET)\n\nThe result of decoding.\n\nFields:\n\nsuccess_tag::Bool: whether the decoding is successful.\nerror_qubits::ET: the error qubits.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.FWSWeightedGraph","page":"Manual","title":"TensorQEC.FWSWeightedGraph","text":"FWSWeightedGraph{T}\n\nA weighted graph that uses the Floyd-Warshall algorithm to find the shortest path. The last vertex stands for the boundary.\n\nFields:\n\nedges::Vector{SimpleWeightedEdge{Int,T}}: the edges of the graph.\nv2e::Vector{Vector{Int}}: the vertex to edge mapping.\ndists::Matrix{T}: the distance matrix.\nerror_path::Matrix{Vector{Int}}: the path matrix that stores the shortest path between each pair of vertices.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.FlatDecodingProblem","page":"Manual","title":"TensorQEC.FlatDecodingProblem","text":"FlatDecodingProblem\n\nInteger programming decoder can not directly apply to a tensor network probability distribution. We need to use auxiliary variables to represent each non-zero element of every tensor. The FlatDecodingProblem is a representation of the probability distribution in a flat form.\n\nFields\n\ntanner::SimpleTannerGraph: The Tanner graph\ncode::Vector{Vector{Int}}: The tensor code of the probability distribution\npvec::Vector{Vector{Float64}}: The probability vector\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.GeneralDecodingProblem","page":"Manual","title":"TensorQEC.GeneralDecodingProblem","text":"GeneralDecodingProblem(tanner::SimpleTannerGraph, ptn::TensorNetwork)\n\nA general decoding problem. Fields:\n\ntanner::SimpleTannerGraph: the Tanner graph\nptn::TensorNetwork: the probability distributions, qubits are labeled as 1:qubit_num\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.IPDecoder","page":"Manual","title":"TensorQEC.IPDecoder","text":"IPDecoder <: AbstractGeneralDecoder\n\nAn integer programming based decoder.\n\nKeyword Arguments\n\noptimizer = SCIP.Optimizer: The optimizer to use for solving the integer programming problem\nverbose::Bool = false: Whether to print the verbose output\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.IndependentDepolarizingDecodingProblem","page":"Manual","title":"TensorQEC.IndependentDepolarizingDecodingProblem","text":"IndependentDepolarizingDecodingProblem(tanner::CSSTannerGraph, pvec::IndependentDepolarizingError)\n\nA decoding problem with independent depolarizing error model. Fields:\n\ntanner::CSSTannerGraph: the Tanner graph\npvec::IndependentDepolarizingError: the independent probability distributions on each qubit\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.IndependentDepolarizingError","page":"Manual","title":"TensorQEC.IndependentDepolarizingError","text":"IndependentDepolarizingError(px::Vector{T}, py::Vector{T}, pz::Vector{T})\n\nIndependent depolarizing error model.\n\nFields:\n\npx::Vector{T}: the probability of each qubit depolarizing in X direction.\npy::Vector{T}: the probability of each qubit depolarizing in Y direction.\npz::Vector{T}: the probability of each qubit depolarizing in Z direction.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.IndependentFlipError","page":"Manual","title":"TensorQEC.IndependentFlipError","text":"IndependentFlipError(p::Vector{T})\n\nIndependent flip error model.\n\nFields:\n\np::Vector{T}: the probability of each qubit flipping.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.MatchingDecoder","page":"Manual","title":"TensorQEC.MatchingDecoder","text":"MatchingDecoder{T<:MatchingSolver} <: AbstractDecoder\n\nA decoder that uses matching algorithm.\n\nFields:\n\nsolver::T: the solver to solve the matching problem.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.MatchingWithBoundary","page":"Manual","title":"TensorQEC.MatchingWithBoundary","text":"MatchingWithBoundary{MT <: AbstractMatrix}\n\nA matching problem with a boundary. Only -1 stabilizers are considered as vertices. +1 stabilizers are removed.\n\nFields:\n\nadj_mat::MT: the adjacency matrix of the graph.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.Mod2","page":"Manual","title":"TensorQEC.Mod2","text":"Mod2 <: Number\nMod2(x::Bool)\n\nA type representing a binary number in the field of integers modulo 2 (GF(2)). In this package, Mod2 algebra is used to represent the parity check matrix, and perform Gaussian elimination.\n\nFields\n\nx::Bool: the binary number.\n\nExamples\n\njulia> Mod2(true) + Mod2(false)\n1₂\n\njulia> Mod2(true) + Mod2(true)\n0₂\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.Pauli","page":"Manual","title":"TensorQEC.Pauli","text":"Pauli <: AbstractPauli{1}\n\nA Pauli operator, i.e. I, X, Y, or Z.\n\nFields\n\nid::Int: the id of the Pauli operator, which is 0 for I, 1 for X, 2 for Y, or 3 for Z.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.PauliGroupElement","page":"Manual","title":"TensorQEC.PauliGroupElement","text":"PauliGroupElement{N} <: AbstractPauli{N}\n\nA Pauli group element is a Pauli string with a phase factor of im^k where k is in range 0-3.\n\nFields\n\ncoeff::Int: the coefficient of the Pauli string, i.e. im^{coeff}. It should be in range 0-3.\nps::PauliString{N}: the Pauli string.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.PauliString","page":"Manual","title":"TensorQEC.PauliString","text":"PauliString{N} <: AbstractPauli{N}\nPauliString(operators::NTuple{N, Pauli}) where N\nPauliString(pairs::Pair...)\n\nA Pauli string is a tensor product of Pauli operators, e.g. XYZ. The matrix representation of a Pauli string is evaluated as\n\nA = bigotimes_i=1^N sigma_operatorsN-i+1\n\nwhere operators is the array of Pauli operators. Note the order of operators is following the little-endian convention, i.e. the first qubit is the least significant qubit. For example, the Pauli string XYZ has matrix representation Z ⊗ Y ⊗ X.\n\nFields\n\noperators::NTuple{N, Pauli}: the array of Pauli operators.\n\nArguments\n\npairs::Pair...: the pairs of locations and Pauli operators.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.QCInfo","page":"Manual","title":"TensorQEC.QCInfo","text":"QCInfo(data_qubits::Vector{Int},ancilla_qubits::Vector{Int},nq::Int)\nQCInfo(data_qubits::Vector{Int},nq::Int)\n\nA struct to store the qubit information of a quantum circuit.\n\nFields\n\ndata_qubits: The data qubit indices.\nancilla_qubits: The ancilla qubit indices. If not specified, it is set to the complement of data_qubits in 1:nq\nnq: The total number of qubits.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.ShorCode","page":"Manual","title":"TensorQEC.ShorCode","text":"ShorCode\n\nConstruct a Shor code instance.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.SimpleTannerGraph","page":"Manual","title":"TensorQEC.SimpleTannerGraph","text":"SimpleTannerGraph(nq::Int, ns::Int, q2s::Vector{Vector{Int}}, s2q::Vector{Vector{Int}}, H::Matrix{Mod2})\n\nTanner graph for a classical linear code.\n\nFields\n\nnq: number of qubits\nns: number of stabilizers\nq2s: a list of lists, q2s[i] is the list of stabilizers that contain qubit i\ns2q: a list of lists, s2q[i] is the list of qubits that stabilizer i contains\nH: the parity check matrix, H[i,j] = 1 means that the i-th stabilizer contains the j-th qubit\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.SimpleTannerGraph-Tuple{Int64, Vector{Vector{Int64}}}","page":"Manual","title":"TensorQEC.SimpleTannerGraph","text":"SimpleTannerGraph(nq::Int, sts::Vector{Vector{Int}})\n\nConstruct a Tanner graph from a list of stabilizers.\n\nArguments\n\nnq: number of qubits\nsts: a list of parity checks, each parity check is a list of bits.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.SteaneCode","page":"Manual","title":"TensorQEC.SteaneCode","text":"SteaneCode\n\nConstruct a Steane code instance.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.SumOfPaulis","page":"Manual","title":"TensorQEC.SumOfPaulis","text":"SumOfPaulis{T<:Number, N} <: AbstractPauli{N}\n\nA sum of Pauli strings is a linear combination of Pauli strings, e.g. c_1 P_1 + c_2 P_2 + cdots + c_n P_n.\n\nFields\n\nitems::Vector{Pair{T, PauliString{N}}}: the vector of pairs of coefficients and Pauli strings.\n\nExamples\n\njulia> p1 = 0.5 * P\"IXY\" + 0.6 * P\"XZI\"\n0.6 * XZI + 0.5 * IXY\n\njulia> p2 = 0.7 * P\"YZI\" + 0.8 * P\"XZI\"\n0.8 * XZI + 0.7 * YZI\n\njulia> 0.2 * p1 + p2\n0.92 * XZI + 0.7 * YZI + 0.1 * IXY\n\njulia> p1 * p2\n0.48 + 0.0im * III + 0.0 + 0.42im * ZII + 0.0 - 0.4im * XYY + 0.0 - 0.35im * YYY\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.SurfaceCode","page":"Manual","title":"TensorQEC.SurfaceCode","text":"SurfaceCode(m::Int, n::Int)\n\nConstruct a surface code with m rows and n columns. \n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.TNMAP","page":"Manual","title":"TensorQEC.TNMAP","text":"TNMAP(;optimizer::CodeOptimizer=default_optimizer()) <: AbstractGeneralDecoder\n\nA tensor network based maximum a posteriori (MAP) decoder, which finds the most probable configuration of the error pattern.\n\nKeyword Arguments\n\noptimizer::CodeOptimizer = TreeSA(): The optimizer to use for optimizing the tensor network contraction order.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.TableDecoder","page":"Manual","title":"TensorQEC.TableDecoder","text":"TableDecoder(d::Int)\n\nA decoder that uses a truth table to decode.\n\nArguments\n\nd: The maximum number of errors to consider\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.TruthTable","page":"Manual","title":"TensorQEC.TruthTable","text":"TruthTable\n\nThe truth table for error correction.\n\nFields\n\ntable::Dict{Int,Int}: The truth table for error correction.\nnum_qubits::Int: The number of qubits.\nnum_st::Int: The number of stabilizers.\nd::Int64: The maximum number of errors.\n\n\n\n\n\n","category":"type"},{"location":"man/#TensorQEC.ToricCode-Tuple{Int64, Int64}","page":"Manual","title":"TensorQEC.ToricCode","text":"ToricCode(m::Int, n::Int)\n\nConstruct a Toric code with m rows and n columns. \n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.annotate_history-Union{Tuple{TensorQEC.CliffordSimulateResult{N}}, Tuple{N}} where N","page":"Manual","title":"TensorQEC.annotate_history","text":"annotate_history(res::CliffordSimulateResult{N})\n\nAnnotate the history of Pauli strings in the result of clifford_simulate.\n\nArguments\n\nres: The result of clifford_simulate.\n\nReturns\n\ndraw: The visualization of the history.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.check_logical_error-Tuple{CSSErrorPattern, CSSErrorPattern, Matrix{Mod2}, Matrix{Mod2}}","page":"Manual","title":"TensorQEC.check_logical_error","text":"check_logical_error(errored_qubits1::CSSErrorPattern, errored_qubits2::CSSErrorPattern, lx::Matrix{Mod2}, lz::Matrix{Mod2})\n\nCheck if there is a logical error between two error patterns for a CSS code.\n\nInput:\n\nerrored_qubits1: the first error pattern.\nerrored_qubits2: the second error pattern.\nlx: the logical operator for X stabilizers.\nlz: the logical operator for Z stabilizers.\n\nOutput:\n\nlogical_error: true if there is a logical error, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.check_logical_error-Tuple{Vector{Mod2}, Vector{Mod2}, Matrix{Mod2}}","page":"Manual","title":"TensorQEC.check_logical_error","text":"check_logical_error(errored_qubits1::Vector{Mod2}, errored_qubits2::Vector{Mod2}, lz::Matrix{Mod2})\n\nCheck if there is a logical error between two error patterns by checking whether the difference of the two error patterns is a logical operator.\n\nInput:\n\nerrored_qubits1: the first error pattern.\nerrored_qubits2: the second error pattern.\nlz: the logical operator for Z stabilizers.\n\nOutput:\n\nlogical_error: true if there is a logical error, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.clifford_group-Tuple{Int64}","page":"Manual","title":"TensorQEC.clifford_group","text":"clifford_group(n::Int)\n\nGenerate the n-qubit Clifford group.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.clifford_network-Tuple{YaoBlocks.ChainBlock}","page":"Manual","title":"TensorQEC.clifford_network","text":"clifford_network(qc::ChainBlock)\n\nGenerate a Clifford network from a quantum circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.clifford_simulate-Union{Tuple{N}, Tuple{PauliString{N}, YaoBlocks.ChainBlock}} where N","page":"Manual","title":"TensorQEC.clifford_simulate","text":"clifford_simulate(::Type{T} = ComplexF64, ps::PauliString, qc::ChainBlock) where {T}\n\nMap the Pauli string ps by a quantum circuit qc. \n\nArguments\n\nps: The Pauli string.\nqc: The quantum circuit.\n\nReturns\n\nresult: A CliffordSimulateResult records the output Pauli string, the phase factor, the simplified circuit, and the history of Pauli strings.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.code_distance-Tuple{CSSTannerGraph}","page":"Manual","title":"TensorQEC.code_distance","text":"code_distance(tanner::CSSTannerGraph)\n\nCalculate the code distance of a CSS code.\n\nInput:\n\ntanner: the tanner graph of the CSS code.\n\nOutput:\n\nd: the distance of the code.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.coherent_error_unitary-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Real}} where T","page":"Manual","title":"TensorQEC.coherent_error_unitary","text":"coherent_error_unitary(u::AbstractMatrix{T}, error_rate::Real; cache::Union{Vector, Nothing} = nothing) where T\n\nGenerate the error unitary near the given error rate.\n\nArguments\n\nu: The original unitary.\nerror_rate: The error rate.\ncache: The vector to store the error rate.\n\nReturns\n\nq: The errored unitary.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.compile-Tuple{TensorQEC.AbstractDecoder, TensorQEC.AbstractTannerGraph}","page":"Manual","title":"TensorQEC.compile","text":"compile(decoder::AbstractDecoder, tanner::AbstractTannerGraph)\n\nCompile the decoder to specific tanner graph and prior probability distributions.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.correction_circuit-Tuple{Dict{Int64, Int64}, Int64, Int64, AbstractVector{Int64}, Int64}","page":"Manual","title":"TensorQEC.correction_circuit","text":"correction_circuit(table::Dict{Int,Int}, num_qubits::Int, num_st::Int, st_pos::AbstractVector{Int}, total_qubits::Int)\n\nGenerate the error correction circuit by embedding the truth table into the quantum circuit.\n\nArguments\n\ntable: The truth table for error correction.\nnum_qubits: The number of qubits in the circuit.\nnum_st: The number of stabilizers.\nst_pos: The indices of ancilla qubits that measure stabilizers.\ntotal_qubits: The total number of qubits in the circuit.\n\nReturns\n\nqc: The error correction circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.correction_dict-Union{Tuple{N}, Tuple{Array{PauliString{N}, 1}, Int64}} where N","page":"Manual","title":"TensorQEC.correction_dict","text":"correction_dict(st::Vector{PauliString{N}}, d::Int64; et=\"XZ\")\n\nGenerate the correction dictionary for the given stabilizers.\n\nArguments\n\nst: The vector of pauli strings, composing the generator of stabilizer group.\nd: The maximum number of errors.\net: The type of error to be corrected. It can be \"X\", \"Z\", or \"XZ\". Default is \"XZ\".\n\nReturns\n\ntable: The correction dictionary, mapping the syndrome to the corresponding error pattern.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.correction_pauli_string-Tuple{Int64, Dict{Int64, Bool}, Dict{Int64, Vector{Float64}}}","page":"Manual","title":"TensorQEC.correction_pauli_string","text":"correction_pauli_string(qubit_num::Int, syn::Dict{Int, Bool}, prob::Dict{Int, Vector{Float64}})\n\nGenerate the error Pauli string in the coding space. To correct the error, we still need to transform it to the physical space.\n\nArguments\n\nqubit_num: The number of qubits.\nsyn: The syndrome dictionary.\nprob: The inferred error probability of each physical qubit in coding space.\n\nReturns\n\nps: The error Pauli string in the coding space.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.decode-Tuple{TensorQEC.AbstractDecoder, TensorQEC.AbstractTannerGraph, TensorQEC.AbstractSyndrome}","page":"Manual","title":"TensorQEC.decode","text":"decode(decoder::AbstractDecoder, problem::AbstractDecodingProblem, syndrome::AbstractSyndrome)\ndecode(compiled_decoder::CompiledDecoder, syndrome::AbstractSyndrome)\n\nDecode the syndrome using the decoder.\n\nInput:\n\ndecoder::AbstractDecoder: the decoder.\nproblem::AbstractDecodingProblem: the decoding problem.\nsyndrome::AbstractSyndrome: the syndrome.\ncompiled_decoder::CompiledDecoder: the compiled decoder.\n\nOutput:\n\ndecoding_result::DecodingResult: the decoding result.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.encode_stabilizers-Union{Tuple{AbstractArray{PauliString{N}, 1}}, Tuple{N}} where N","page":"Manual","title":"TensorQEC.encode_stabilizers","text":"encode_stabilizers(stabilizers::AbstractVector{PauliString{N}}) where N\n\nGenerate the encoding circuit for the given stabilizers.\n\nArguments\n\nstabilizers: The vector of pauli strings, composing the generator of stabilizer group.\n\nReturns\n\nqc: The encoding circuit.\ndata_qubits: The indices of data qubits.\nbimat: The structure storing the encoding information.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.error_pairs-Tuple{T} where T<:Real","page":"Manual","title":"TensorQEC.error_pairs","text":"error_pairs(error_rate::T; gates = nothing) where {T <: Real}\n\nGenerate the error pairs for the given error rate.\n\nArguments\n\nerror_rate: The error rate.\ngates: The gates to be errored. If not specified, it is set to [X,Y,Z,H,CCZ,ConstGate.Toffoli,ConstGate.CNOT,ConstGate.CZ]\n\nReturns\n\npairs: The error pairs.\nvec: The vector to store the error rate to each gate.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.error_quantum_circuit-Union{Tuple{T}, Tuple{YaoBlocks.ChainBlock, T}} where T<:Real","page":"Manual","title":"TensorQEC.error_quantum_circuit","text":"error_quantum_circuit(qc::ChainBlock, error_rate::T ) where {T <: Real}\n\nGenerate the error quantum circuit for the given error rate.\n\nArguments\n\nqc: The quantum circuit.\nerror_rate: The error rate.\n\nReturns\n\neqc: The error quantum circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.error_quantum_circuit_pair_replace-Union{Tuple{T}, Tuple{YaoBlocks.ChainBlock, T}} where T<:Real","page":"Manual","title":"TensorQEC.error_quantum_circuit_pair_replace","text":"error_quantum_circuit_pair_replace(qc::ChainBlock, error_rate::T ) where {T <: Real}\nerror_quantum_circuit_pair_replace(qc::ChainBlock, pairs)\n\nGenerate the error quantum circuit for the given error rate. The errored gate to the same type of gate is the same.\n\nArguments\n\nqc: The quantum circuit.\nerror_rate: The error rate.\npairs: The error gates used to replace the original gates.\n\nReturns\n\nqcf: The error quantum circuit.\nvec: The vector to store the error rate to each gate.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.fidelity_tensornetwork-Tuple{YaoBlocks.ChainBlock, QCInfo}","page":"Manual","title":"TensorQEC.fidelity_tensornetwork","text":"fidelity_tensornetwork(qc::ChainBlock,qc_info::QCInfo)\n\nGenerate the tensor network representation of the quantum circuit fidelity with the given QCInfo, where ancilla qubits are initilized at zero state and partial traced after the circuit. The data qubits are traced out.\n\nArguments\n\nqc: The quantum circuit.\nqc_info: The qubit information of the quantum circuit\n\nReturns\n\ntn: The tensor network representation of the quantum circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.get_graph-Tuple{SimpleTannerGraph}","page":"Manual","title":"TensorQEC.get_graph","text":"get_graph(tanner::SimpleTannerGraph)\nget_graph(ctg::CSSTannerGraph)\n\nGet the simple graph of a simple tanner graph or a CSS tanner graph.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.iid_error-Union{Tuple{T}, Tuple{T, Int64}} where T<:Real","page":"Manual","title":"TensorQEC.iid_error","text":"\"     iid_error(p::T,n::Int) where T <: Real\n\nGenerate an independent and identically distributed flip error model.\n\nInput:\n\np::T: the probability of each qubit flipping.\nn::Int: the number of qubits.\n\nOutput:\n\nem::IndependentFlipError: the independent flip error model.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.iid_error-Union{Tuple{T}, Tuple{T, T, T, Int64}} where T<:Real","page":"Manual","title":"TensorQEC.iid_error","text":"iid_error(px::T,py::T,pz::T,n::Int) where T <: Real\n\nGenerate an independent and identically distributed depolarizing error model.\n\nInput:\n\npx::T: the probability of each qubit depolarizing in X direction.\npy::T: the probability of each qubit depolarizing in Y direction.\npz::T: the probability of each qubit depolarizing in Z direction.\nn::Int: the number of qubits.\n\nOutput:\n\nem::IndependentDepolarizingError: the independent depolarizing error model.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.inference-Tuple{Vector{Int64}, CSSBimatrix, YaoBlocks.ChainBlock, Vector{Vector{Float64}}}","page":"Manual","title":"TensorQEC.inference","text":"inference(measure_outcome::Vector{Int}, code::CSSBimatrix, qc::ChainBlock, p::Vector{Vector{Float64}})\n\nInfer the error probability of each qubit from the measurement outcome of the stabilizers.\n\nArguments\n\nmeasure_outcome: The measurement outcome of the stabilizers, which is either 1 or -1.\ncode: The structure storing the encoding information.\nqc: The encoding circuit.\np: The prior error probability of each physical qubit.\n\nReturns\n\nps_ec_phy: The error Pauli string for error correction.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.isanticommute-Tuple{Any, Any}","page":"Manual","title":"TensorQEC.isanticommute","text":"isanticommute(a::PauliGroupElement, b::PauliGroupElement)\n\nReturns true if two Pauli group elements anticommute, i.e. a b + b a = 0.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.isanticommute-Union{Tuple{N}, Tuple{PauliString{N}, PauliString{N}}} where N","page":"Manual","title":"TensorQEC.isanticommute","text":"isanticommute(a::PauliString, b::PauliString)\n\nReturns true if two Pauli strings anticommute, i.e. a b + b a = 0.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.load_table-Tuple{String, Int64, Int64}","page":"Manual","title":"TensorQEC.load_table","text":"load_table(filename::String, num_qubits::Int, num_st::Int)\n\nLoad a truth table from a file.\n\nArguments\n\nfilename: The name of the file to load from\nnum_qubits: The number of qubits in the code\nnum_st: The number of stabilizers in the code\n\nReturns\n\nA TruthTable loaded from the file.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.logical_operator-Tuple{CSSTannerGraph}","page":"Manual","title":"TensorQEC.logical_operator","text":"logical_operator(tanner::CSSTannerGraph)\n\nCalculate the logical operators of a CSS code.\n\nInput:\n\ntanner: the tanner graph of the CSS code.\n\nOutput:\n\nlx: the logical operator for X stabilizers.\nlz: the logical operator for Z stabilizers.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.make_table-Tuple{CSSTannerGraph, Int64, TensorQEC.AbstractSyndromeConflict}","page":"Manual","title":"TensorQEC.make_table","text":"make_table(tanner::CSSTannerGraph, d::Int, sc::AbstractSyndromeConflict)\n\nGenerate a truth table for error correction from a CSS Tanner graph.\n\nArguments\n\ntanner: The CSS Tanner graph representing the stabilizer code\nd: The maximum number of errors to consider\nsc: The syndrome conflict resolution strategy\n\nReturns\n\nA TruthTable containing the mapping from syndromes to error patterns.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.measure_circuit_fault_tol-Union{Tuple{Array{PauliString{N}, 1}}, Tuple{N}} where N","page":"Manual","title":"TensorQEC.measure_circuit_fault_tol","text":"measure_circuit_fault_tol(sts::Vector{PauliString{N}}) where N\n\nGenerate the Shor type measurement circuit for fault tolerant measurement.\n\nArguments\n\nsts: The vector of Pauli strings, composing the generator of stabilizer group.\n\nReturns\n\nqc: The measurement circuit.\nst_pos: The ancilla qubit indices that measrue corresponding stabilizers.\nnum_qubits: The total number of qubits in the circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.measure_circuit_steane-Union{Tuple{N}, Tuple{Int64, Array{PauliString{N}, 1}}} where N","page":"Manual","title":"TensorQEC.measure_circuit_steane","text":"measure_circuit_steane(data_qubit::Int, sts::Vector{PauliString{N}};qcen = nothing) where N\n\nGenerate the Steane type measurement circuit.\n\nArguments\n\ndata_qubit: The index of the data qubit.\nsts: The vector of Pauli strings, composing the generator of stabilizer group.\nqcen: The encoding circuit. If nothing, the measurement circuit will not contain the encoder for ancilla qubits.\n\nReturns\n\nqc: The measurement circuit.\nst_pos: The ancilla qubit indices that measrue corresponding stabilizers.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.measure_syndrome!-Union{Tuple{N}, Tuple{YaoAPI.AbstractRegister, AbstractArray{PauliString{N}, 1}}} where N","page":"Manual","title":"TensorQEC.measure_syndrome!","text":"measure_syndrome!(reg::AbstractRegister, stabilizers::AbstractVector{PauliString{N}}) where N\n\nMeasure the given stabilizers.\n\nArguments\n\nreg: The quantum register.\nstabilizers: The vector of pauli strings, composing the generator of stabilizer group.\n\nReturns\n\nmeasure_outcome: The measurement outcome of the stabilizers, which is either 1 or -1.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.pauli_basis-Union{Tuple{Val{N}}, Tuple{N}} where N","page":"Manual","title":"TensorQEC.pauli_basis","text":"pauli_basis(nqubits::Int)\npauli_basis(::Val{N}) where N\n\nGenerate the n-qubit Pauli basis, which is a vector of PauliStrings. The size of the vector is 4^N.\n\nExamples\n\njulia> pauli_basis(1)\n4-element Vector{PauliString{1}}:\n I\n X\n Y\n Z\n\nThe single qubit Pauli basis has 4 elements.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.pauli_decomposition-Tuple{AbstractMatrix}","page":"Manual","title":"TensorQEC.pauli_decomposition","text":"pauli_decomposition(m::AbstractArray; atol=0)\npauli_decomposition(dm::DensityMatrix; atol=0)\npauli_decomposition(reg::ArrayReg; atol=0)\n\nDecompose a matrix of size 2^N x 2^N (or density matrix or array register) into the Pauli basis:\n\nm = sum_i=1^4^N c_i cdot sigma_i\n\nwhere c_i is the coefficient of the i-th Pauli string, and \\sigma_i is the i-th Pauli string.\n\nKeyword Arguments\n\natol::Float64: the absolute tolerance for the coefficients. If the coefficient is less than atol, it will be ignored.\n\nExamples\n\njulia> pauli_decomposition(mat(P\"X\" + 0.5 * P\"Z\"))\n1.0 - 0.0im * X + 0.5 - 0.0im * Z\n\nThe return value is a SumOfPaulis object, which is recovered from the matrix representation of the Pauli expression.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.pauli_repr-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Manual","title":"TensorQEC.pauli_repr","text":"pauli_repr(m::AbstractMatrix) -> Matrix\npauli_repr(m::AbstractBlock) -> Matrix\n\nReturns the representation of a matrix in the Pauli basis. It should not be confused with pauli_decomposition, this function returns a matrix that represents how a Pauli string is mapped to others by this matrix. If a matrix has size 2^N x 2^N, its Pauli basis representation will be a 4^N x 4^N real matrix.\n\nExamples\n\nThe Pauli operator flips the sign of Y and Z in the Pauli basis.\n\njulia> pauli_repr(mat(P\"X\"))\n4×4 Matrix{Float64}:\n 1.0  0.0   0.0   0.0\n 0.0  1.0   0.0   0.0\n 0.0  0.0  -1.0   0.0\n 0.0  0.0   0.0  -1.0\n\nBecause we have XZX = -Z and XZY = -Y.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.pauli_string_map_iter-Union{Tuple{N}, Tuple{PauliString{N}, YaoBlocks.ChainBlock}} where N","page":"Manual","title":"TensorQEC.pauli_string_map_iter","text":"pauli_string_map_iter(ps::PauliString{N}, qc::ChainBlock) where N\n\nMap the Pauli string ps by a quantum circuit qc. Return the mapped Pauli string.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.perm_of_paulistring-Union{Tuple{M}, Tuple{N}, Tuple{PauliString{N}, Pair{NTuple{M, Int64}, <:CliffordGate}}} where {N, M}","page":"Manual","title":"TensorQEC.perm_of_paulistring","text":"perm_of_paulistring(ps::PauliString, operation::Pair{NTuple{M, Int}, <:PermMatrixCSC}) where {M}\n\nMap the Pauli string ps by a permutation matrix pm. Return the mapped Pauli string and the phase factor.\n\nArguments\n\nps: The Pauli string.\noperation: A pair of the positions to apply the permutation and the permutation matrix.\n\nReturns\n\nps: The mapped Pauli string.\nval: The phase factor.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.place_qubits-Tuple{YaoAPI.AbstractRegister, Vector{Int64}, Int64}","page":"Manual","title":"TensorQEC.place_qubits","text":"place_qubits(reg0::AbstractRegister, data_qubits::Vector{Int}, num_qubits::Int)\n\nPlace the data qubits to the specified position. The other qubits are filled with zero state.\n\nArguments\n\nreg0: The data register.\ndata_qubits: The indices of data qubits.\nnum_qubits: The total number of qubits.\n\nReturns\n\nreg: The register with data qubits placed at the specified position.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.product_graph-Tuple{SimpleTannerGraph, SimpleTannerGraph}","page":"Manual","title":"TensorQEC.product_graph","text":"product_graph(tanner1::SimpleTannerGraph, tanner2::SimpleTannerGraph)\n\nConstruct the hyper-graph product code of two simple tanner graphs.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.random_error_qubits-Tuple{IndependentFlipError}","page":"Manual","title":"TensorQEC.random_error_qubits","text":"random_error_qubits(qubit_number::Int, em::AbstractErrorModel)\n\nGenerate a random error pattern for a given number of qubits and an error model.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.random_ldpc-Tuple{Int64, Int64, Int64}","page":"Manual","title":"TensorQEC.random_ldpc","text":"random_ldpc(n1::Int,n2::Int,nq::Int)\n\nConstruct a random LDPC code with given connectivity numbers.\n\nInput:\n\nn1: the number of stabilizers that each qubit is checked by.\nn2: the number of qubits that each stabilizer contains.\nnq: the number of qubits in the code.\n\nOutput:\n\ntanner: the tanner graph of the LDPC code.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.reduce2general-Tuple{CSSTannerGraph, IndependentDepolarizingError}","page":"Manual","title":"TensorQEC.reduce2general","text":"reduce2general(tanner::CSSTannerGraph, pvec::IndependentDepolarizingError)\n\nReduce a CSS Tanner graph to a general decoding problem.\n\nInput:\n\ntanner::CSSTannerGraph: the CSS Tanner graph.\npvec::IndependentDepolarizingError: the error model.\n\nOutput:\n\ngdp::GeneralDecodingProblem: the general decoding problem.\ncsg::CSSToGeneralDecodingProblem: the reduction result.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.save_table-Tuple{TruthTable, String}","page":"Manual","title":"TensorQEC.save_table","text":"save_table(tb::TruthTable, filename::String)\n\nSave a truth table to a file.\n\nArguments\n\ntb: The truth table to save\nfilename: The name of the file to save to\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.simulation_tensornetwork-Tuple{YaoBlocks.ChainBlock, QCInfo}","page":"Manual","title":"TensorQEC.simulation_tensornetwork","text":"simulation_tensornetwork(qc::ChainBlock,qc_info::QCInfo)\n\nGenerate the tensor network representation of the quantum circuit with the given QCInfo, where ancilla qubits are initilized at zero state and partial traced after the circuit.\n\nArguments\n\nqc: The quantum circuit.\nqc_info: The qubit information of the quantum circuit\n\nReturns\n\ntn: The tensor network representation of the quantum circuit.\ninput_indices: The input indices of the tensor network.\noutput_indices: The output indices of the tensor network.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.stabilizers-Tuple{SurfaceCode}","page":"Manual","title":"TensorQEC.stabilizers","text":"stabilizers(tc::ToricCode)\nstabilizers(sc::SurfaceCode)\nstabilizers(shor::ShorCode)\nstabilizers(steane::SteaneCode)\nstabilizers(code832::Code832)\n\nGet the stabilizers of the code instances.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.stg2uaimodel-Tuple{SimpleTannerGraph, YaoToEinsum.TensorNetwork}","page":"Manual","title":"TensorQEC.stg2uaimodel","text":"stg2uaimodel(tanner::SimpleTannerGraph, ptn::TensorNetwork)\n\nConvert a Tanner graph and a tensor network to a UAIModel.\n\nArguments\n\ntanner::SimpleTannerGraph: The Tanner graph.\nptn::TensorNetwork: The tensor network.\n\nReturns\n\nuai::UAIModel: The UAIModel.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.sumofpaulis-Union{Tuple{Array{Pair{T, PauliString{N}}, 1}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Manual","title":"TensorQEC.sumofpaulis","text":"sumofpaulis(items::Vector{Pair{T, PauliString{N}}}) where {T, N}\n\nReturns a sum of Pauli strings from a vector of pairs of coefficients and Pauli strings. Unlike SumOfPaulis, it will merge the same Pauli strings and sum up the coefficients.\n\nKeyword Arguments\n\natol::Float64: the absolute tolerance for the coefficients. If the coefficient is less than atol, it will be ignored.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.syndrome_extraction-Tuple{Vector{Mod2}, Matrix{Mod2}}","page":"Manual","title":"TensorQEC.syndrome_extraction","text":"syndrome_extraction(errored_qubits::Vector{Mod2}, H::Matrix{Mod2})\nsyndrome_extraction(errored_qubits::Vector{Mod2}, tanner::SimpleTannerGraph)\nsyndrome_extraction(error_patterns::CSSErrorPattern, tanner::CSSTannerGraph)\n\nExtract the syndrome from the error pattern.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.syndrome_inference-Union{Tuple{T}, Tuple{CliffordNetwork{T}, Dict{Int64, Bool}, Vector{Vector{Float64}}}} where T","page":"Manual","title":"TensorQEC.syndrome_inference","text":"syndrome_inference(cl::CliffordNetwork{T}, syn::Dict{Int,Bool}, p::Vector{Vector{Float64}}) where T\n\nInfer the error probability of each qubit from the measurement outcome of the stabilizers.\n\nArguments\n\ncl: The Clifford network.\nsyn: The syndrome dictionary.\np: The prior error probability of each physical qubit.\n\nReturns\n\npinf: The inferred error probability of each physical qubit in coding space. For errored stabilizers, there are two possibilities: X or Y error. For unerrored stabilizers, there are also two possibilities: no error or Z error. For unmeasured qubits, there are four possibilities: no error, X error, Y error, Z error. Therefore the length of each vector in pinf may be 2 or 4.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.to_perm_matrix-Tuple{AbstractMatrix}","page":"Manual","title":"TensorQEC.to_perm_matrix","text":"to_perm_matrix(matrix; atol=1e-8)\n\nConvert a general matrix to a permutation matrix.\n\nArguments\n\nm: The matrix representation of the gate.\natol: The tolerance to zeros in the matrix.\n\nReturns\n\npm: The permutation matrix. pm.perm is the permutation vector, pm.vals is the phase factor.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.transformed_syndrome_dict-Tuple{Vector{Int64}, CSSBimatrix}","page":"Manual","title":"TensorQEC.transformed_syndrome_dict","text":"transformed_syndrome_dict(measure_outcome::Vector{Int}, code::CSSBimatrix)\n\nGenerate the syndrome dictionary on the transformed stabilizers from the measurement outcome. \n\nArguments\n\nmeasure_outcome: The measurement outcome of the stabilizers, which is either 1 or -1.\ncode: The structure storing the encoding information.\n\nReturns\n\nsyn_dict: The syndrome dictionary on the transformed stabilizers. 1 is transformed to 0, -1 is transformed to 1. \n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.yaoblock-Tuple{Pauli}","page":"Manual","title":"TensorQEC.yaoblock","text":"yaoblock(x::Pauli)\n\nReturns the Yao block corresponding to a Pauli operator.\n\n\n\n\n\n","category":"method"},{"location":"man/#TensorQEC.@P_str-Tuple{String}","page":"Manual","title":"TensorQEC.@P_str","text":"@P_str(str::String)\n\nA macro to convert a string to a Pauli string.\n\nExample\n\njulia> P\"IX\"\nIX\n\n\n\n\n\n","category":"macro"},{"location":"man/#Multiprocessing","page":"Manual","title":"Multiprocessing","text":"","category":"section"},{"location":"man/#TensorQEC.SimpleMultiprocessing.multiprocess_run","page":"Manual","title":"TensorQEC.SimpleMultiprocessing.multiprocess_run","text":"multiprocess_run(func, inputs::AbstractVector)\n\nExecute function func on inputs with multiple processing.\n\nExample\n\nSuppose we have a file run.jl with the following contents\n\nusing GenericTensorNetworks.SimpleMultiprocessing\n\nresults = multiprocess_run(x->x^2, randn(8))\n\nIn an terminal, you may run the script with 4 processes by typing\n\n$ julia -p4 run.jl\n      From worker 2:\t[ Info: running argument -0.17544008350172655 on device 2\n      From worker 5:\t[ Info: running argument 0.34578117779452555 on device 5\n      From worker 3:\t[ Info: running argument 2.0312551239727705 on device 3\n      From worker 4:\t[ Info: running argument -0.7319353419291961 on device 4\n      From worker 2:\t[ Info: running argument 0.013132180639054629 on device 2\n      From worker 3:\t[ Info: running argument 0.9960101782201602 on device 3\n      From worker 4:\t[ Info: running argument -0.5613942832743966 on device 4\n      From worker 5:\t[ Info: running argument 0.39460402723831134 on device 5\n\n\n\n\n\n","category":"function"},{"location":"generated/codes/#QEC-Codes","page":"QEC Codes","title":"QEC Codes","text":"","category":"section"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"We provide a number of quantum error correction codes.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"using TensorQEC","category":"page"},{"location":"generated/codes/#Toric-Code","page":"QEC Codes","title":"Toric Code","text":"","category":"section"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"The Toric code is a 2D topological code[Kitaev]. We can define a Toric code instance by ToricCode.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"tc = ToricCode(2, 3)","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"Here is a schematic diagram of 2*3 Toric code: (Image: )","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"The Toric code has two types of stabilizers: X stabilizers and Z stabilizers. X stabilizers are plaquettes of the lattice, and Z stabilizers are vertices of the lattice. We can get the stabilizers of the toric code by","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"st = stabilizers(tc)","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"Note the order of pauli strings is following the big-endian convention. For example, the Pauli string XYZ means X_1Y_2Z_3.","category":"page"},{"location":"generated/codes/#Surface-Code","page":"QEC Codes","title":"Surface Code","text":"","category":"section"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"The surface code is a 2D topological code[Kitaev]. Similarly to Toric code, we can define a surface code instance by SurfaceCode and get the stabilizers of the surface code by stabilizers.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"sc = SurfaceCode(3, 3)\nst = stabilizers(sc)","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"Here is a schematic diagram of 3*3 surface code: (Image: )","category":"page"},{"location":"generated/codes/#Shor-Code","page":"QEC Codes","title":"Shor Code","text":"","category":"section"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"The [[9,1,3]] Shor code[Shor] functions by concatenating each qubit of a phase-flip with a bit-flip repetition code, allowing it to correct both types of errors at the same time. We can define a Shor code instance by ShorCode.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"shor = ShorCode()\nst = stabilizers(shor)","category":"page"},{"location":"generated/codes/#Steane-Code","page":"QEC Codes","title":"Steane Code","text":"","category":"section"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"The [[7,1,3]] Steane is constructed using the classical binary [7,4,3] Hamming code[Steane]. We can define a Steane code instance by SteaneCode.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"(Image: )","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"steane = SteaneCode()\nst = stabilizers(steane)","category":"page"},{"location":"generated/codes/#[[8,3,2]]-Code","page":"QEC Codes","title":"[[8,3,2]] Code","text":"","category":"section"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"The [[8,3,2]] CSS code is the smallest non-trivial 3D color code[Menendez][Code832]. We can define a CSS [[8,3,2]] code instance by Code832.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"(Image: )","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"code832 = Code832()\nst = stabilizers(code832)","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"[Kitaev]: Kitaev, A. Y. Fault-Tolerant Quantum Computation by Anyons. Annals of Physics 2003, 303 (1), 2–30. https://doi.org/10.1016/S0003-4916(02)00018-0.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"[Menendez]: Menendez, D. H.; Ray, A.; Vasmer, M. Implementing Fault-Tolerant Non-Clifford Gates Using the [[8,3,2]] Color Code. arXiv September 15, 2023. http://arxiv.org/abs/2309.08663.","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"[Code832]: THE SMALLEST INTERESTING COLOUR CODE","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"[Shor]: Shor, P. W. (1995). Scheme for reducing decoherence in quantum computer memory. Physical Review A, 52(4), R2493–R2496. https://doi.org/10.1103/PhysRevA.52.R2493","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"[Steane]: Steane, A. (1997). Multiple-particle interference and quantum error correction. Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences, 452(1954), 2551–2577. https://doi.org/10.1098/rspa.1996.0136","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"","category":"page"},{"location":"generated/codes/","page":"QEC Codes","title":"QEC Codes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/simulation/#Measurement-Free-QEC","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"","category":"section"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"This example demonstrates how to use tensor network to simulate a error correction process. We use the 713 steane code and the measurement-free QEC[Heußen] as an example. There are non-clifford gates in the quantum circuit, so we use tensor network to simulate the process.","category":"page"},{"location":"generated/simulation/#Background-Knowledge","page":"Measurement-Free QEC","title":"Background Knowledge","text":"","category":"section"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Traditional quantum error correction requires measurment and feed back into quantum circuit. Limited by laws of physics, measurements are doomed to be costly timewise, e.g. in the NMR computing schme[Boykin]. Decoherence may very well happen during measurement. Measurement-free quantum error correction was a scheme to circumvent this problem.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Measurement-free quantum error correction was first proposed by Aharonov et. al [Aharonov] in the 90s. Without using measurements, a universal set of fault-tolerant gates on encoded qubits was constructed in section 4 of the paper [Aharonov]. They used CSS code and assumed noise is local and un-correlated in time, i.e Markovian. They obtained a threshold of eta_c approx 10^-6, which is the considerably lower than that of the conventional method[DiVincenzo]. This threshold was later improved to be \"only about an order of magnitude worse than conventional schemes\" [Ercan] with the Bacon-Shor code[Paz].","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Experimental realizations include","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Realization on trapped ion platform [Schindler]\nRealization on bosonic code qubits. [Gertler]","category":"page"},{"location":"generated/simulation/#Implementation","page":"Measurement-Free QEC","title":"Implementation","text":"","category":"section"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Traditional quantum error correction involves several key procedures. First, the encoding procedure involves mapping the logical quantum information into a larger, redundant quantum state using QEC codes such as the Shor code or the surface code. Usually, those quantum code are defined by stabilizers. Then, the syndrome extraction is the process that we extract the value of the stabilizers into ancilla qubits. And we measure the ancilla qubits to detect the value of stabilizers. After detection, the error syndromes are identified, which indicates the presence and location of errors in the quantum state. Next, the error correction procedure uses quantum gates to apply operations that reverse the effects of errors, effectively restoring the quantum state to its original form.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"In the measurement-free QEC protocol, we embed the classical truth table of the error correction into the quantum circuit directly. For example, if we measure the stabilizer 1 and 2 to ancilla qubit 1 and 2, and if they are both in state 1rangle, we know that there is an X error on the first qubit. We can encode this information into the quantum circuit directly by a multi-controlled-X gate.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"(Image: )","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Since such multi-controlled gate is non-clifford, we can't simulate it with clifford circuit simulator.","category":"page"},{"location":"generated/simulation/#Definition-of-Stabilizers-and-Encoding-Circuits","page":"Measurement-Free QEC","title":"Definition of Stabilizers and Encoding Circuits","text":"","category":"section"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"using TensorQEC, TensorQEC.Yao\nusing TensorQEC.OMEinsum\nst = stabilizers(SteaneCode())","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Generate the encoding circuits of the stabilizers by encode_stabilizers. qcen is the encoding circuit, data_qubits are the qubits that we should put initial qubtis in, and code is the structure records information of the encoding circuit.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"qcen, data_qubits, code = encode_stabilizers(st)\nvizcircuit(qcen)","category":"page"},{"location":"generated/simulation/#Syndrome-Extraction-and-Measurement-Free-Error-Correction","page":"Measurement-Free QEC","title":"Syndrome Extraction and Measurement-Free Error Correction","text":"","category":"section"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"First, we generate the steane measurement circuit by measure_circuit_steane and st_pos records the ancilla qubits that store the measurement results of the stabilizers.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"qcm,st_pos  = measure_circuit_steane(data_qubits[1],st;qcen)\nvizcircuit(qcm)","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Then we generate correction dictionary for the error correction by correction_dict.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"table = correction_dict(st, 1;et = \"Z\")","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Now we use correction_circuit to generate the measurement-free correction circuit by encoding the truth table on the quantum circuit directly.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"num_qubits = nqubits(qcm)\nqccr = correction_circuit(table, num_qubits, 3, 25:27, 27)\nvizcircuit(qccr)","category":"page"},{"location":"generated/simulation/#Circuit-Simulation-with-Tensor-Networks","page":"Measurement-Free QEC","title":"Circuit Simulation with Tensor Networks","text":"","category":"section"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"We connect the encoding circuit, the measurement circuit, and the correction circuit to form a full circuit. And we apply a Y error on the third qubit after encoding.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"qcf=chain(subroutine(num_qubits, qcen, 1:7),put(27,3=>Z),qcm,qccr,subroutine(num_qubits, qcen', 1:7))\nvizcircuit(qcf)","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Then we transform the circuit to a tensor network and optimize its contraction order. QCInfo records the information of the quantum circuit, including the data qubits and the number of qubits. fidelity_tensornetwork constructs the tensor network to calculate the fidelity after error correction.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"tn = fidelity_tensornetwork(qcf, QCInfo(data_qubits, 27))","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"Finally, we optimize the contraction order and contract the tensor network to get the infidelity after error correction.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"optnet = optimize_code(tn, TreeSA(; ntrials=1, niters=5), OMEinsum.MergeVectors())\ninfidelity = 1 - abs(contract(optnet)[1])","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"[Heußen]: Heußen, S., Locher, D. F., & Müller, M. (2024). Measurement-Free Fault-Tolerant Quantum Error Correction in Near-Term Devices. PRX Quantum, 5(1), 010333. https://doi.org/10.1103/PRXQuantum.5.010333","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"[Aharonov]: Aharonov, D. and Ben-Or, M. (1997). Fault-tolerant quantum computation with constant error. In: Proceedings of the twenty-ninth annual ACM symposium on Theory of computing; pp. 176–188.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"[Boykin]: Roychowdhury, V. P.; Boykin, P.; Vatan, F. and Mor, T. (jul 2004). Fault Tolerant Computation on Ensemble Quantum Computers. In: 2004 International Conference on Dependable Systems and Networks (IEEE Computer Society, Los Alamitos, CA, USA); p. 157.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"[DiVincenzo]: DiVincenzo, D. P. and Aliferis, P. (2007). Effective fault-tolerant quantum computation with slow measurements. Physical review letters 98, 020501.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"[Ercan]: Ercan, H. E.; Ghosh, J.; Crow, D.; Premakumar, V. N.; Joynt, R.; Friesen, M. and Coppersmith, S. (2018). Measurement-free implementations of small-scale surface codes for quantum-dot qubits. Physical Review A 97, 012318.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"[Paz]: Paz-Silva, G. A.; Brennen, G. K. and Twamley, J. (2010). On fault-tolerance with noisy and slow measurements, arXiv preprint arXiv:1002.1536.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"[Schindler]: Schindler, P.; Barreiro, J. T.; Monz, T.; Nebendahl, V.; Nigg, D.; Chwalla, M.; Hennrich, M. and Blatt, R. (2011). Experimental Repetitive Quantum Error Correction. Science 332, 1059–1061, arXiv:https://www.science.org/doi/pdf/10.1126/science.1203329.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"[Gertler]: Gertler, J. M.; Baker, B.; Li, J.; Shirol, S.; Koch, J. and Wang, C. (2021). Protecting a bosonic qubit with autonomous quantum error correction. Nature 590, 243–248.","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"","category":"page"},{"location":"generated/simulation/","page":"Measurement-Free QEC","title":"Measurement-Free QEC","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#TensorQEC","page":"Home","title":"TensorQEC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package utilizes the tensor network to study the properties of quantum error correction(QEC). The main features include","category":"page"},{"location":"","page":"Home","title":"Home","text":"Incoherent Quantum error correction: In the incoherent quantum error correction scheme, finding the most likely true error from the error syndrome is a standard probabilistic inference problem on boolean variables. This problem is closely connected to tensor networks[Ferris], which can be solved with existing tools such as TensorInference.jl. Examples are given in the following sections:\nInference with Tensor Network\nCoherent quantum error correction: Unlike Clifford gate, non-Clifford gates can not be simulated efficiently in general. By converting the quantum circuit into a tensor network, we can simulate small coherent quantum error correction circuits. Examples are given in the following sections:\nCoherent Error Simulation\nMeasurement-Free QEC","category":"page"},{"location":"","page":"Home","title":"Home","text":"[Ferris]: Ferris, A. J.; Poulin, D. Tensor Networks and Quantum Error Correction. Phys. Rev. Lett. 2014, 113 (3), 030501. https://doi.org/10.1103/PhysRevLett.113.030501.","category":"page"},{"location":"generated/ipdecoder/#Mixed-Integer-Programming-for-Decoding","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming for Decoding","text":"","category":"section"},{"location":"generated/ipdecoder/#Problem-Statement","page":"Mixed-Integer Programming Decoder","title":"Problem Statement","text":"","category":"section"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"The parity-check matrices of a CSS quantum code are H_x in mathbbF^m_x times n_2 and H_z in mathbbF^m_z times n_2 where mathbbF_2 is the finite field with two elements, n is the number of qubits, m_x is the number of X-stabilizers, and m_z is the number of Z-stabilizers. We can use CSSTannerGraph to generate a tanner graph for a CSS quantum code.","category":"page"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"using TensorQEC\ntanner = CSSTannerGraph(SteaneCode());\nnothing #hide","category":"page"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"And the parity-check matrix of X-stabilizers of the Steane code is","category":"page"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"tanner.stgx.H","category":"page"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"The error vectors mathbfxyz in mathbbF^n_2 are binary vectors. The j-th element of mathbfx is 1 if the j-th qubit is flipped by an X-error, and 0 otherwise. There is at most one error per qubit, i.e., mathbfx_j + mathbfy_j + mathbfz_j leq 1. random_error_qubits can be used to generate a random error pattern for a given number of qubits and an error model.","category":"page"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"using Random; Random.seed!(110)\nerror_pattern = random_error_qubits(iid_error(0.1,0.1,0.1,7))","category":"page"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"Here we decompose Y errors into X and Z errors. The error pattern is Y_4X_6 =iX_4X_6Z_4.","category":"page"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"The syndrome of X-stabilizers and Z-stabilizers are H_x(mathbfy+mathbfz) = s_x in mathbbF^m_x_2 and H_z (mathbfx+mathbfy) = s_z in mathbbF^m_z_2. We can use syndrome_extraction to extract the syndrome of a given error pattern.","category":"page"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"syndrome = syndrome_extraction(error_pattern,tanner)","category":"page"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"The goal is to find the most-likely error mathbfxmathbfymathbfz in mathbbF^n_2 given the syndrome s_x and s_z.","category":"page"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"Suppose that the error distributions on different qubits are independent to each other. And we use p_sigma j to denote the probability of the j-th qubit being flipped by an error of type sigma in xyz. Then the logarithm of the total error probability is","category":"page"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"L(mathbfxyz) = sum_j=1^n (mathbfx_j log p_xj + mathbfy_j log p_yj + mathbfz_j log p_zj + (1-mathbfx_j-mathbfy_j-mathbfz_j) log (1-p_xj-p_yj-p_zj))","category":"page"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"The resulting mixed-integer program can be summarized as:","category":"page"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"beginaligned\ntextmaximize quad  L(mathbfxyz) \ntextsubject to quad  H_x (mathbfy+z) = s_x \n H_z (mathbfx+y) = s_z \n mathbfxyz in 01^n \n mathbfx_j + mathbfy_j + mathbfz_j leq 1 quad j=1ldotsn\nendaligned","category":"page"},{"location":"generated/ipdecoder/#Mixed-Integer-Programming","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming","text":"","category":"section"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"Since H_x (mathbfy+z) = s_x in mathbbF_2 is equivalent to H_x (mathbfy+z) = s_x mod 2 in mathbbZ, we can convert above programming problem into a mixed-integer programming problem as follows:","category":"page"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"beginaligned\ntextmaximize quad  L(mathbfxyz) \ntextsubject to quad  H_x (mathbfy+z) = s_x + 2mathbfk \n H_z (mathbfx+y) = s_z + 2mathbfl \n mathbfxyz in 01^n \n mathbfx_j + mathbfy_j + mathbfz_j leq 1 quad j=1ldotsn\n mathbfk in mathbbZ^m_x mathbfl in mathbbZ^m_z\nendaligned","category":"page"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"Here mathbfk and mathbfl are auxiliary variables to convert the modulo operation into linear constraints.","category":"page"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"We implement the above mixed-integer programming problem in IPDecoder and solve it with JuMP.jl and HiGHS.jl. We can use decode to decode the syndrome with this integer programming decoder.","category":"page"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"decoder = IPDecoder()\ndecode(decoder, tanner, syndrome)","category":"page"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"Here we get a different error pattern X_2Z_4. That is because the default error probability is 005 for each qubit and each error type. And this error pattern has the same syndrome as the previous one. If we slightly increase the X and Y error probability, we can get the correct error pattern Y_4X_6.","category":"page"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"decode(decoder, tanner, syndrome, iid_error(0.06, 0.06, 0.05,7))","category":"page"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"","category":"page"},{"location":"generated/ipdecoder/","page":"Mixed-Integer Programming Decoder","title":"Mixed-Integer Programming Decoder","text":"This page was generated using Literate.jl.","category":"page"}]
}
