<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Measurement-Free QEC · TensorQEC.jl</title><meta name="title" content="Measurement-Free QEC · TensorQEC.jl"/><meta property="og:title" content="Measurement-Free QEC · TensorQEC.jl"/><meta property="twitter:title" content="Measurement-Free QEC · TensorQEC.jl"/><meta name="description" content="Documentation for TensorQEC.jl."/><meta property="og:description" content="Documentation for TensorQEC.jl."/><meta property="twitter:description" content="Documentation for TensorQEC.jl."/><meta property="og:url" content="https://nzy1997.github.io/TensorQEC.jl/generated/simulation/"/><meta property="twitter:url" content="https://nzy1997.github.io/TensorQEC.jl/generated/simulation/"/><link rel="canonical" href="https://nzy1997.github.io/TensorQEC.jl/generated/simulation/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TensorQEC.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Topics</span><ul><li><a class="tocitem" href="../../clifford/">Pauli Basis and Clifford group</a></li><li><a class="tocitem" href="../codes/">QEC Codes</a></li><li><a class="tocitem" href="../inference/">Inference with Tensor Network</a></li><li><a class="tocitem" href="../coherent/">Coherent Error Simulation</a></li><li class="is-active"><a class="tocitem" href>Measurement-Free QEC</a><ul class="internal"><li><a class="tocitem" href="#Background-Knowledge"><span>Background Knowledge</span></a></li><li><a class="tocitem" href="#Implementation"><span>Implementation</span></a></li><li><a class="tocitem" href="#Definition-of-Stabilizers-and-Encoding-Circuits"><span>Definition of Stabilizers and Encoding Circuits</span></a></li><li><a class="tocitem" href="#Syndrome-Extraction-and-Measurement-Free-Error-Correction"><span>Syndrome Extraction and Measurement-Free Error Correction</span></a></li><li><a class="tocitem" href="#Circuit-Simulation-with-Tensor-Networks"><span>Circuit Simulation with Tensor Networks</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Decoders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../error_model/">Error Model and Syndrome Extraction</a></li><li><a class="tocitem" href="../decoder/">Decoder Interface</a></li><li><a class="tocitem" href="../ipdecoder/">Mixed-Integer Programming Decoder</a></li></ul></li><li><a class="tocitem" href="../../performancetips/">Performance Tips</a></li></ul></li><li><a class="tocitem" href="../../man/">Manual</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Topics</a></li><li class="is-active"><a href>Measurement-Free QEC</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Measurement-Free QEC</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/nzy1997/TensorQEC.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/nzy1997/TensorQEC.jl/blob/main/examples/simulation.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Measurement-Free-QEC"><a class="docs-heading-anchor" href="#Measurement-Free-QEC">Measurement-Free QEC</a><a id="Measurement-Free-QEC-1"></a><a class="docs-heading-anchor-permalink" href="#Measurement-Free-QEC" title="Permalink"></a></h1><p>This example demonstrates how to use tensor network to simulate a error correction process. We use the <span>$[[7,1,3]]$</span> steane code and the measurement-free QEC<sup class="footnote-reference"><a id="citeref-Heußen" href="#footnote-Heußen">[Heußen]</a></sup> as an example. There are non-clifford gates in the quantum circuit, so we use tensor network to simulate the process.</p><h2 id="Background-Knowledge"><a class="docs-heading-anchor" href="#Background-Knowledge">Background Knowledge</a><a id="Background-Knowledge-1"></a><a class="docs-heading-anchor-permalink" href="#Background-Knowledge" title="Permalink"></a></h2><p>Traditional quantum error correction requires measurment and feed back into quantum circuit. Limited by laws of physics, measurements are doomed to be costly timewise, e.g. in the NMR computing schme<sup class="footnote-reference"><a id="citeref-Boykin" href="#footnote-Boykin">[Boykin]</a></sup>. Decoherence may very well happen during measurement. Measurement-free quantum error correction was a scheme to circumvent this problem.</p><p>Measurement-free quantum error correction was first proposed by Aharonov et. al <sup class="footnote-reference"><a id="citeref-Aharonov" href="#footnote-Aharonov">[Aharonov]</a></sup> in the 90s. Without using measurements, a universal set of fault-tolerant gates on encoded qubits was constructed in section 4 of the paper <sup class="footnote-reference"><a id="citeref-Aharonov" href="#footnote-Aharonov">[Aharonov]</a></sup>. They used CSS code and assumed noise is local and un-correlated in time, i.e Markovian. They obtained a threshold of <span>$\eta_c \approx 10^{-6}$</span>, which is the considerably lower than that of the conventional method<sup class="footnote-reference"><a id="citeref-DiVincenzo" href="#footnote-DiVincenzo">[DiVincenzo]</a></sup>. This threshold was later improved to be &quot;only about an order of magnitude worse than conventional schemes&quot; <sup class="footnote-reference"><a id="citeref-Ercan" href="#footnote-Ercan">[Ercan]</a></sup> with the Bacon-Shor code<sup class="footnote-reference"><a id="citeref-Paz" href="#footnote-Paz">[Paz]</a></sup>.</p><p>Experimental realizations include</p><ul><li><p>Realization on trapped ion platform <sup class="footnote-reference"><a id="citeref-Schindler" href="#footnote-Schindler">[Schindler]</a></sup></p></li><li><p>Realization on bosonic code qubits. <sup class="footnote-reference"><a id="citeref-Gertler" href="#footnote-Gertler">[Gertler]</a></sup></p></li></ul><h2 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h2><p>Traditional quantum error correction involves several key procedures. First, the encoding procedure involves mapping the logical quantum information into a larger, redundant quantum state using QEC codes such as the Shor code or the surface code. Usually, those quantum code are defined by stabilizers. Then, the syndrome extraction is the process that we extract the value of the stabilizers into ancilla qubits. And we measure the ancilla qubits to detect the value of stabilizers. After detection, the error syndromes are identified, which indicates the presence and location of errors in the quantum state. Next, the error correction procedure uses quantum gates to apply operations that reverse the effects of errors, effectively restoring the quantum state to its original form.</p><p>In the measurement-free QEC protocol, we embed the classical truth table of the error correction into the quantum circuit directly. For example, if we measure the stabilizer 1 and 2 to ancilla qubit 1 and 2, and if they are both in state <span>$|1\rangle$</span>, we know that there is an X error on the first qubit. We can encode this information into the quantum circuit directly by a multi-controlled-X gate.</p><p><img src="../../images/ccx.svg" alt/></p><p>Since such multi-controlled gate is non-clifford, we can&#39;t simulate it with clifford circuit simulator.</p><h2 id="Definition-of-Stabilizers-and-Encoding-Circuits"><a class="docs-heading-anchor" href="#Definition-of-Stabilizers-and-Encoding-Circuits">Definition of Stabilizers and Encoding Circuits</a><a id="Definition-of-Stabilizers-and-Encoding-Circuits-1"></a><a class="docs-heading-anchor-permalink" href="#Definition-of-Stabilizers-and-Encoding-Circuits" title="Permalink"></a></h2><pre><code class="language-julia hljs">using TensorQEC, TensorQEC.Yao
using TensorQEC.OMEinsum
st = stabilizers(SteaneCode())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{PauliString{7}}:
 XIXIXIX
 IXXIIXX
 IIIXXXX
 ZIZIZIZ
 IZZIIZZ
 IIIZZZZ</code></pre><p>Generate the encoding circuits of the stabilizers by <a href="../../man/#TensorQEC.encode_stabilizers-Union{Tuple{AbstractArray{PauliString{N}, 1}}, Tuple{N}} where N"><code>encode_stabilizers</code></a>. <code>qcen</code> is the encoding circuit, <code>data_qubits</code> are the qubits that we should put initial qubtis in, and <code>code</code> is the structure records information of the encoding circuit.</p><pre><code class="language-julia hljs">qcen, data_qubits, code = encode_stabilizers(st)
vizcircuit(qcen)</code></pre><img src="6ab76448.svg" alt="Example block output"/><h2 id="Syndrome-Extraction-and-Measurement-Free-Error-Correction"><a class="docs-heading-anchor" href="#Syndrome-Extraction-and-Measurement-Free-Error-Correction">Syndrome Extraction and Measurement-Free Error Correction</a><a id="Syndrome-Extraction-and-Measurement-Free-Error-Correction-1"></a><a class="docs-heading-anchor-permalink" href="#Syndrome-Extraction-and-Measurement-Free-Error-Correction" title="Permalink"></a></h2><p>First, we generate the steane measurement circuit by <a href="../../man/#TensorQEC.measure_circuit_steane-Union{Tuple{N}, Tuple{Int64, Array{PauliString{N}, 1}}} where N"><code>measure_circuit_steane</code></a> and <code>st_pos</code> records the ancilla qubits that store the measurement results of the stabilizers.</p><pre><code class="language-julia hljs">qcm,st_pos  = measure_circuit_steane(data_qubits[1],st;qcen)
vizcircuit(qcm)</code></pre><img src="09c02c3f.svg" alt="Example block output"/><p>Then we generate correction dictionary for the error correction by <a href="../../man/#TensorQEC.correction_dict-Union{Tuple{N}, Tuple{Array{PauliString{N}, 1}, Int64}} where N"><code>correction_dict</code></a>.</p><pre><code class="language-julia hljs">table = correction_dict(st, 1;et = &quot;Z&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Int64, Int64} with 7 entries:
  5 =&gt; 16
  4 =&gt; 8
  6 =&gt; 32
  7 =&gt; 64
  2 =&gt; 2
  3 =&gt; 4
  1 =&gt; 1</code></pre><p>Now we use <a href="../../man/#TensorQEC.correction_circuit-Tuple{Dict{Int64, Int64}, Int64, Int64, AbstractVector{Int64}, Int64}"><code>correction_circuit</code></a> to generate the measurement-free correction circuit by encoding the truth table on the quantum circuit directly.</p><pre><code class="language-julia hljs">num_qubits = nqubits(qcm)
qccr = correction_circuit(table, num_qubits, 3, 25:27, 27)
vizcircuit(qccr)</code></pre><img src="cca42138.svg" alt="Example block output"/><h2 id="Circuit-Simulation-with-Tensor-Networks"><a class="docs-heading-anchor" href="#Circuit-Simulation-with-Tensor-Networks">Circuit Simulation with Tensor Networks</a><a id="Circuit-Simulation-with-Tensor-Networks-1"></a><a class="docs-heading-anchor-permalink" href="#Circuit-Simulation-with-Tensor-Networks" title="Permalink"></a></h2><p>We connect the encoding circuit, the measurement circuit, and the correction circuit to form a full circuit. And we apply a Y error on the third qubit after encoding.</p><pre><code class="language-julia hljs">qcf=chain(subroutine(num_qubits, qcen, 1:7),put(27,3=&gt;Z),qcm,qccr,subroutine(num_qubits, qcen&#39;, 1:7))
vizcircuit(qcf)</code></pre><img src="fb1d024e.svg" alt="Example block output"/><p>Then we transform the circuit to a tensor network and optimize its contraction order. <a href="../../man/#TensorQEC.QCInfo"><code>QCInfo</code></a> records the information of the quantum circuit, including the data qubits and the number of qubits. <a href="../../man/#TensorQEC.fidelity_tensornetwork-Tuple{YaoBlocks.ChainBlock, QCInfo}"><code>fidelity_tensornetwork</code></a> constructs the tensor network to calculate the fidelity after error correction.</p><pre><code class="language-julia hljs">tn = fidelity_tensornetwork(qcf, QCInfo(data_qubits, 27))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TensorNetwork
Time complexity: 2^244.0
Space complexity: 2^0.0
Read-write complexity: 2^10.817783121774532</code></pre><p>Finally, we optimize the contraction order and contract the tensor network to get the infidelity after error correction.</p><pre><code class="language-julia hljs">optnet = optimize_code(tn, TreeSA(; ntrials=1, niters=5), OMEinsum.MergeVectors())
infidelity = 1 - abs(contract(optnet)[1])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Heußen"><a class="tag is-link" href="#citeref-Heußen">Heußen</a>Heußen, S., Locher, D. F., &amp; Müller, M. (2024). Measurement-Free Fault-Tolerant Quantum Error Correction in Near-Term Devices. PRX Quantum, 5(1), 010333. https://doi.org/10.1103/PRXQuantum.5.010333</li><li class="footnote" id="footnote-Aharonov"><a class="tag is-link" href="#citeref-Aharonov">Aharonov</a>Aharonov, D. and Ben-Or, M. (1997). Fault-tolerant quantum computation with constant error. In: Proceedings of the twenty-ninth annual ACM symposium on Theory of computing; pp. 176–188.</li><li class="footnote" id="footnote-Boykin"><a class="tag is-link" href="#citeref-Boykin">Boykin</a>Roychowdhury, V. P.; Boykin, P.; Vatan, F. and Mor, T. (jul 2004). Fault Tolerant Computation on Ensemble Quantum Computers. In: 2004 International Conference on Dependable Systems and Networks (IEEE Computer Society, Los Alamitos, CA, USA); p. 157.</li><li class="footnote" id="footnote-DiVincenzo"><a class="tag is-link" href="#citeref-DiVincenzo">DiVincenzo</a>DiVincenzo, D. P. and Aliferis, P. (2007). Effective fault-tolerant quantum computation with slow measurements. Physical review letters 98, 020501.</li><li class="footnote" id="footnote-Ercan"><a class="tag is-link" href="#citeref-Ercan">Ercan</a>Ercan, H. E.; Ghosh, J.; Crow, D.; Premakumar, V. N.; Joynt, R.; Friesen, M. and Coppersmith, S. (2018). Measurement-free implementations of small-scale surface codes for quantum-dot qubits. Physical Review A 97, 012318.</li><li class="footnote" id="footnote-Paz"><a class="tag is-link" href="#citeref-Paz">Paz</a>Paz-Silva, G. A.; Brennen, G. K. and Twamley, J. (2010). On fault-tolerance with noisy and slow measurements, arXiv preprint arXiv:1002.1536.</li><li class="footnote" id="footnote-Schindler"><a class="tag is-link" href="#citeref-Schindler">Schindler</a>Schindler, P.; Barreiro, J. T.; Monz, T.; Nebendahl, V.; Nigg, D.; Chwalla, M.; Hennrich, M. and Blatt, R. (2011). Experimental Repetitive Quantum Error Correction. Science 332, 1059–1061, arXiv:https://www.science.org/doi/pdf/10.1126/science.1203329.</li><li class="footnote" id="footnote-Gertler"><a class="tag is-link" href="#citeref-Gertler">Gertler</a>Gertler, J. M.; Baker, B.; Li, J.; Shirol, S.; Koch, J. and Wang, C. (2021). Protecting a bosonic qubit with autonomous quantum error correction. Nature 590, 243–248.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../coherent/">« Coherent Error Simulation</a><a class="docs-footer-nextpage" href="../error_model/">Error Model and Syndrome Extraction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Wednesday 18 June 2025 03:43">Wednesday 18 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
